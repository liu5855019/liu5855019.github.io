{"meta":{"title":"daimu's blog","subtitle":"","description":"daimu's blog","author":"daimu","url":"https://blog.zaiyuan.cc","root":"/"},"pages":[{"title":"关于","date":"2023-04-21T09:21:03.244Z","updated":"2023-04-21T09:21:03.244Z","comments":true,"path":"about/index.html","permalink":"https://blog.zaiyuan.cc/about/index.html","excerpt":"这是摘要 dd","text":"这是摘要 dd 这是正文"},{"title":"Project","date":"2022-12-14T07:27:32.373Z","updated":"2021-10-08T02:53:16.000Z","comments":true,"path":"project/index.html","permalink":"https://blog.zaiyuan.cc/project/index.html","excerpt":"","text":""},{"title":"Series","date":"2022-12-14T07:34:12.667Z","updated":"2021-10-08T02:53:16.000Z","comments":true,"path":"series/index.html","permalink":"https://blog.zaiyuan.cc/series/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2023-04-21T08:42:06.040Z","updated":"2023-04-21T08:42:06.040Z","comments":true,"path":"tags/index.html","permalink":"https://blog.zaiyuan.cc/tags/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2023-04-21T09:02:36.901Z","updated":"2023-04-21T09:02:36.901Z","comments":true,"path":"categories/index.html","permalink":"https://blog.zaiyuan.cc/categories/index.html","excerpt":"","text":""},{"title":"朋友们","date":"2023-04-21T09:16:37.010Z","updated":"2023-04-21T09:16:37.010Z","comments":true,"path":"friends/index.html","permalink":"https://blog.zaiyuan.cc/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"经常使用的排序算法","slug":"code/算法/经常使用的排序算法","date":"2023-05-06T02:40:39.240Z","updated":"2023-05-04T22:28:17.000Z","comments":true,"path":"code/算法/经常使用的排序算法/","link":"","permalink":"https://blog.zaiyuan.cc/code/%E7%AE%97%E6%B3%95/%E7%BB%8F%E5%B8%B8%E4%BD%BF%E7%94%A8%E7%9A%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"","text":"插入排序 插入排序非常类似于整扑克牌。在开始摸牌时，左手是空的，牌面朝下放在桌上。接着，一次从桌上摸起一张牌，并将它插入到左手一把牌中的正确位置上。为了找到这张牌的正确位置，要将它与手中已有的牌从右到左地进行比较。无论什么时候，左手中的牌都是排好序的。 如果输入数组已经是排好序的话，插入排序出现最佳情况，其运行时间是输入规模的一个线性函数。如果输入数组是逆序排列的，将出现最坏情况。平均情况与最坏情况一样，其时间代价是Θ(n2)。 也许你没有意识到，但其实你的思考过程是这样的：现在抓到一张7，把它和手里的牌从右到左依次比较，7比10小，应该再往左插，7比5大，好，就插这里。为什么比较了10和5就可以确定7的位置？为什么不用再比较左边的4和2呢？因为这里有一个重要的前提：手里的牌已经是排好序的。现在我插了7之后，手里的牌仍然是排好序的，下次再抓到的牌还可以用这个方法插入。编程对一个数组进行插入排序也是同样道理，但和插入扑克牌有一点不同，不可能在两个相邻的存储单元之间再插入一个单元，因此要将插入点之后的数据依次往后移动一个单元。插入排序类似于整理扑克牌，从无序列中选择一个值插入到有序列中 冒泡排序*** 冒泡排序法的基本思想：（以升序为例）含有n个元素的数组原则上要进行n-1次排序。对于每一躺的排序，从第一个数开始，依次比较前一个数与后一个数的大小。如果前一个数比后一个数大，则进行交换。这样一轮过后，最大的数将会出现称为最末位的数组元素。第二轮则去掉最后一个数，对前n-1个数再按照上面的步骤找出最大数，该数将称为倒数第二的数组元素……n-1轮过后，就完成了排序。*** 快速排序*** 快速排序是冒泡排序的一种改进，快速排序以一个基准值，将无序列分成两部分（左边小于基准值，右边大于基准值），然后递归。***快速排序由于排序效率在同为O(N*logN)的几种排序方法中效率较高，因此经常被采用，再加上快速排序思想—-分治法也确实实用，因此很多软件公司的笔试面试，包括像腾讯，微软等知名IT公司都喜欢考这个，还有大大小的程序方面的考试如软考，考研中也常常出现快速排序的身影。 选择排序 选择排序：比如在一个长度为N的无序数组中，在第一趟遍历N个数据，找出其中最小的数值与第一个元素交换，第二趟遍历剩下的N-1个数据，找出其中最小的数值与第二个元素交换……第N-1趟遍历剩下的2个数据，找出其中最小的数值与第N-1个元素交换，至此选择排序完成。选择排序是根据找到无序数列中的最大或最小值插入到有序序列尾部来排序 地精排序虽然没写过这个排序,但是个人感觉这个排序很有意思也很快速号称最简单的排序算法,只有一层循环,默认情况下前进冒泡,一旦遇到冒泡的情况发生就往回冒,直到把这个数字放好为止 直接看它排序的过程,待排数组[6 2 4 1 5 9] 先设计一个标识i=0然后从头开始判断,什么时候(i &lt; 6)不成立,什么时候排序结束, 所以,如何控制i的值是这个算法的关键 例如待排数组: [6 2 4 1 5 9] [0 1 2 3 4 5] 看一下具体的排序过程 [ i = 0 ]时啥也不干,先让i自增1,达到值为1才开始真正的比较 交换前[6 2 4 1 5 9][ i = 0] 交换后[6 2 4 1 5 9][ i = 1] [ i = 1 ]比较6和2,发生交换,只要发生交换i就减1 交换前[6 2 4 1 5 9][ i = 1] 交换后[2 6 4 1 5 9][ i = 0] [ i = 0 ]又成0了,啥也不干,自增变成1再说 交换前[2 6 4 1 5 9][ i = 0] 交换后[2 6 4 1 5 9][ i = 1] [ i = 1 ]再比较2和6,不交换,只要不要换就自增1 交换前[2 6 4 1 5 9][ i = 1] 交换后[2 6 4 1 5 9][ i = 2] [ i = 2 ]比较6和4,发生交换,只要交换就减1 交换前[2 6 4 1 5 9][ i = 2] 交换后[2 4 6 1 5 9][ i = 1] [ i = 1 ]比较2和4,不交换,只要不交换就自增1 交换前[2 4 6 1 5 9][ i = 1] 交换后[2 4 6 1 5 9][ i = 2] [ i = 2 ]比较4和6,不交换,只要不交换就自增1 交换前[2 4 6 1 5 9][ i = 2] 交换后[2 4 6 1 5 9][ i = 3] [ i = 3 ]比较6和1,交换,只要交换就减1 交换前[2 4 6 1 5 9][ i = 3] 交换后[2 4 1 6 5 9][ i = 2] [ i = 2 ]比较4和1,交换,只要交换就减1 交换前[2 4 1 6 5 9][ i = 2] 交换后[2 1 4 6 5 9][ i = 1] [ i = 1 ]比较2和1,交换,只要交换就减1 交换前[2 1 4 6 5 9][ i = 1] 交换后[1 2 4 6 5 9][ i = 0] [ i = 0 ]时啥也不干,先让i自增1,达到值为1才开始真正的比较 交换前[1 2 4 6 5 9][ i = 0] 交换后[1 2 4 6 5 9][ i = 1] [ i = 1]比较1和2,不交换,只要不交换就自增1 [ i = 2]比较2和4,不交换,只要不交换就自增1 [ i = 3]比较4和6,不交换,只要不交换就自增1 [ i = 4]比较6和5,交换,只要交换就减1 交换前[1 2 4 6 5 9][ i = 4] 交换后[1 2 4 5 6 9][ i = 3] [ i = 3]比较4和5,不交换,只要不交换就自增1 [ i = 4]比较5和6,不交换,只要不交换就自增1 [ i = 5]比较6和9,不交换,只要不交换就自增1 [ i = 6]表达式(i &lt; n)不成立,排序结束, 顺序输出结果即可:[ 1 2 4 5 6 9] 123456789101112131415161718static void gnome_sort(int[] unsorted)&#123; int i = 0; while (i &lt; unsorted.Length) &#123; if (i == 0 || unsorted[i - 1] &lt;= unsorted[i]) &#123; i++; &#125; else &#123; int tmp = unsorted[i]; unsorted[i] = unsorted[i - 1]; unsorted[i - 1] = tmp; i--; &#125; &#125;&#125; 两个经典文章 1 排序算法2 排序动画","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://blog.zaiyuan.cc/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"机器学习视频地址","slug":"code/算法/机器学习视频地址","date":"2023-05-06T02:40:39.236Z","updated":"2023-05-04T20:07:02.000Z","comments":true,"path":"code/算法/机器学习视频地址/","link":"","permalink":"https://blog.zaiyuan.cc/code/%E7%AE%97%E6%B3%95/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E8%A7%86%E9%A2%91%E5%9C%B0%E5%9D%80/","excerpt":"","text":"#斯坦福大学公开课 ：机器学习课程 传送门算法1: 无监督学习 - 聚类算法 [W,s,v] &#x3D; svd((repmat(sum(x.*x,1),size(x,1),1).*x)*x’)","categories":[],"tags":[]},{"title":"iOS cocoapods","slug":"code/iOS/iOS cocoapods","date":"2023-05-06T02:40:39.218Z","updated":"2023-05-04T23:10:37.000Z","comments":true,"path":"code/iOS/iOS cocoapods/","link":"","permalink":"https://blog.zaiyuan.cc/code/iOS/iOS%20cocoapods/","excerpt":"","text":"Mac 10.14 以上 安装 cocoapods sudo gem install -n &#x2F;usr&#x2F;local&#x2F;bin cocoapods pod update 命令运行失败的时候 在 Podfile 文件中 do 前 加入 source ‘https://github.com/CocoaPods/Specs.git&#39; 命令 , 再次 pod update pod 上传相关1234567891011121314151617181920212223242526# 1.先把 东西写好,上传 github# 2.添加标记git tag 1.1.0# 3.将标记上传git push --tags# 4.修改 podspec 文件# 5.进入 podspec 文件所在目录# 6.检查 podspec 是否修改完成pod spec lint --allow-warnings# 7. 上传 podpod trunk push --allow-warnings其它:#登录过期后1. pod trunk register qq@qq.com &#x27;password&#x27; --verbose2. pod 会发一封邮件到邮箱 (可能在垃圾箱)3. 点击邮箱中链接进行验证4. pod trunk me pod 忽略警告第一种: pod ‘三方名称’, :inhibit_warnings &#x3D;&gt; true 第二种: 忽略所有 platform :ios, ‘9.0’inhibit_all_warnings!","categories":[],"tags":[{"name":"ios","slug":"ios","permalink":"https://blog.zaiyuan.cc/tags/ios/"}]},{"title":"查看一天写了多少代码脚本","slug":"code/iOS/查看一天写了多少代码脚本","date":"2023-05-06T02:40:39.214Z","updated":"2023-05-05T00:54:37.000Z","comments":true,"path":"code/iOS/查看一天写了多少代码脚本/","link":"","permalink":"https://blog.zaiyuan.cc/code/iOS/%E6%9F%A5%E7%9C%8B%E4%B8%80%E5%A4%A9%E5%86%99%E4%BA%86%E5%A4%9A%E5%B0%91%E4%BB%A3%E7%A0%81%E8%84%9A%E6%9C%AC/","excerpt":"","text":"先上结果 在需要检查的目录下运行脚本就能查询到 当前目录 以及 子目录 下 .h .m 的文件数和行数 这样与前一天的结果对比就能知道一天你写了多少代码 具体脚本123456789101112131415161718192021222324252627282930fileCount=0lineCount=0function checkFile() &#123; file=$1 if [ &quot;$&#123;file##*.&#125;&quot;x = &quot;m&quot;x ]||[ &quot;$&#123;file##*.&#125;&quot;x = &quot;h&quot;x ] then let fileCount=fileCount+1 while read line do let lineCount=lineCount+1 done &lt; $&#123;file&#125;# echo $&#123;lineCount&#125; fi&#125;for file in `find . -name &quot;*.m&quot; -o -name &quot;*.h&quot; `do echo $file checkFile $filedoneecho ===================================datepwdecho 总文件数: $&#123;fileCount&#125;echo 总 行 数: $&#123;lineCount&#125;","categories":[],"tags":[]},{"title":"NSTimer 简单用法以及容易造成内存泄漏解决办法","slug":"code/iOS/NSTimer 简单用法以及容易造成内存泄漏解决办法","date":"2023-05-06T02:40:39.206Z","updated":"2023-05-04T22:23:53.000Z","comments":true,"path":"code/iOS/NSTimer 简单用法以及容易造成内存泄漏解决办法/","link":"","permalink":"https://blog.zaiyuan.cc/code/iOS/NSTimer%20%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95%E4%BB%A5%E5%8F%8A%E5%AE%B9%E6%98%93%E9%80%A0%E6%88%90%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","excerpt":"","text":"使用NSTimer最好是升级为属性,容易控制简单使用 设置为属性 @property (nonatomic ,strong) NSTimer *timer; &#x2F;&#x2F;定时器 懒加载 123456-(NSTimer*)timer&#123; if (_timer == nil) &#123; _timer = [NSTimer scheduledTimerWithTimeInterval:0.1 target:self selector:@selector(updateUI) userInfo:nil repeats:YES]; &#125; return _timer;&#125; 开始动画与暂停动画123456789101112/** * 开始动画 */ -(void)beginAnimation&#123; self.timer.fireDate=[NSDate distantPast];&#125; /** * 结束动画 */ -(void)endAnimation&#123; self.timer.fireDate=[NSDate distantFuture];&#125; 如果只是使用的话,这已经完了,但是会造成self无法释放&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 解决办法,在界面要不显示的时候把定时器注销并且置空12345-(void)viewWillDisappear:(BOOL)animated&#123; [super viewWillDisappear:animated]; [self.timer invalidate]; self.timer = nil;&#125; 这样就可以了,可以打印dealloc测试了GCDdispatch source是一个监视某些类型事件的对象。当这些事件发生时，它自动将一个block放入一个dispatch queue的执行例程中。 12345678910111213141516171819202122232425262728/** * 创建dispatch源 * * @param DISPATCH_SOURCE_TYPE_TIMER 事件源的类型 * @param 0 &lt;#0 description#&gt; * @param 0 &lt;#0 description#&gt; * @param dispatch_get_main_queue 在哪个线程上执行 * * @return dispatch_source_t */dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, dispatch_get_main_queue());/** * @param start 控制计时器第一次触发的时刻 * @param interval 每隔多长时间执行一次 * @param leeway 误差值，0表示最小误差，值越小性能消耗越大 */dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, 0 * NSEC_PER_SEC);/** * 事件处理的回调 */dispatch_source_set_event_handler(timer, ^&#123; //取消定时器 dispatch_cancel(timer);&#125;);/** * Dispatch source启动时默认状态是挂起的，我们创建完毕之后得主动恢复，否则事件不会被传递，也不会被执行 */dispatch_resume(timer); GCD定时器的优点有很多，首先不受Mode的影响，而NSTimer受Mode影响时常不能正常工作，除此之外GCD的精确度明显高于NSTimer，这些优点让我们有必要了解GCD定时器这种方法。示例1234567891011121314151617181920212223242526272829-(void)clickOnButton&#123; //获取一个并行队列 (默认优先级队列) dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0); //创建 timer dispatch_source_t timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue); _timer = timer; //设置timer间隔和精度 //interval:间隔 (纳秒),配合NSEC_PER_SEC用就是秒 //leeway:精度 ,最高精度当然就传0。 dispatch_source_set_timer(timer, DISPATCH_TIME_NOW, 1 * NSEC_PER_SEC, 0.1 * NSEC_PER_SEC); //设置回调 WeakObj(self); __block NSInteger count = 0; dispatch_source_set_event_handler(timer, ^&#123; NSString *str = nil; if (count &gt;= 3600) &#123; str = [NSString stringWithFormat:@&quot;%02d:%02d:%02d&quot;,(int)(count/3600),(int)((count%3600)/60),(int)(count%60)]; &#125;else&#123; str = [NSString stringWithFormat:@&quot;%02d:%02d&quot;,(int)(count/60),(int)(count%60)]; &#125; MAIN(^&#123; selfWeak.timeLabel.text = str; &#125;); count++; &#125;); dispatch_resume(timer);&#125;","categories":[],"tags":[]},{"title":"iOS 打包自己的 app 生成ipa给老板用","slug":"code/iOS/iOS 打包自己的 app 生成ipa给老板用","date":"2023-05-06T02:40:39.203Z","updated":"2023-05-04T22:19:50.000Z","comments":true,"path":"code/iOS/iOS 打包自己的 app 生成ipa给老板用/","link":"","permalink":"https://blog.zaiyuan.cc/code/iOS/iOS%20%E6%89%93%E5%8C%85%E8%87%AA%E5%B7%B1%E7%9A%84%20app%20%E7%94%9F%E6%88%90ipa%E7%BB%99%E8%80%81%E6%9D%BF%E7%94%A8/","excerpt":"","text":"1进入developer.apple.com 创建证书 2如果发布证书已经有了请跳过,没有的跟着创建证书 在这里选择你的请求证书,如果没有请求证书,在文章末尾给出请求证书生成过程 创建完成后下载出来 3 创建应用程序(app id) 4 添加老板设备(iPhone) ,如果不知道老板的udid,文章末尾给出用手机查看udid的解决办法 5 生成profile 选择你刚才创建的 app id 选择你创建的发布证书 选择设备(最少要有老板iPhone) 给生成的profile取个名字 至此证书创建完成 6 把刚才下载的两个文件都双击了7 在工程中选择刚创建的profile名字(28处) 8 填入app id 选择team (你登录的$99账号的主号) 9 打包 导出ipa 至此打包结束,可以上传到蒲公英等网站供老板下载了 附1 生成请求证书 打开钥匙串 附2 用手机拿到老板的udid (用Xcode获得都会就不说了) 文章到此结束,喜欢的请收藏,转载请标明出处","categories":[],"tags":[]},{"title":"UIDocumentInteractionController 预览文件与解决内存无法释放问题","slug":"code/iOS/UIDocumentInteractionController 预览文件与解决内存无法释放问题","date":"2023-05-06T02:40:39.194Z","updated":"2023-05-04T20:28:56.000Z","comments":true,"path":"code/iOS/UIDocumentInteractionController 预览文件与解决内存无法释放问题/","link":"","permalink":"https://blog.zaiyuan.cc/code/iOS/UIDocumentInteractionController%20%E9%A2%84%E8%A7%88%E6%96%87%E4%BB%B6%E4%B8%8E%E8%A7%A3%E5%86%B3%E5%86%85%E5%AD%98%E6%97%A0%E6%B3%95%E9%87%8A%E6%94%BE%E9%97%AE%E9%A2%98/","excerpt":"","text":"##设置为属性 @property (nonatomic ,strong) UIDocumentInteractionController *documentInteractionController; 创建 - ( void )setupDocumentControllerWithURL:( NSURL *)url &#123; if ( self.documentInteractionController == nil )&#123; self.documentInteractionController = [ UIDocumentInteractionController interactionControllerWithURL :url]; self.documentInteractionController.delegate = self ; &#125; else &#123; self.documentInteractionController.URL = url; &#125; &#125; /** * 打开文件 */ -(void)openFileWithPath:(NSString*)path&#123; NSURL* URL = [NSURL fileURLWithPath:path]; if (URL) &#123; [ self setupDocumentControllerWithURL :URL]; // CGRect rect = CGRectMake ( 0 , 0 , kScreenW , kScreenH); // [self.documentInteractionController presentOptionsMenuFromRect:rect inView:self.view animated:YES];//包含快速预览菜单 [self.documentInteractionController presentPreviewAnimated:YES]; &#125; &#125; ##必须需要实现代理方法才能预览 /** * 预览用的Controller */ -(UIViewController *)documentInteractionControllerViewControllerForPreview:(UIDocumentInteractionController *)controller&#123; return self; &#125; /** * 预览用的View */ -(UIView *)documentInteractionControllerViewForPreview:(UIDocumentInteractionController *)controller&#123; return self.view; &#125; - (void)documentInteractionControllerWillBeginPreview:(UIDocumentInteractionController *)controller&#123; NSLog(@&quot;will begin preview&quot;); &#125; - (void)documentInteractionControllerDidEndPreview:(UIDocumentInteractionController *)controller&#123; NSLog(@&quot;did end preview&quot;); &#125; ###这样使用是可以了.当你要在下载文件完成后打开文件,会这样写 NSData *data = responseObject; BOOL isWrite = [data writeToFile:[MyTools filePathInTmpWithFile:fileName] atomically:YES]; MAIN(^&#123; [self.mbHud hideAnimated:YES]; &#125;); if (isWrite) &#123;//调用打开文件 [self openFileWithPath:[MyTools filePathInTmpWithFile:fileName]]; &#125;else&#123; MAIN(^&#123; [MyTools showAlertWithTitle:kLocStr(@&quot;提示&quot;) andContent:kLocStr(@&quot;打开文件失败!&quot;) andBlock:nil atController:self]; &#125;); &#125; ####这样会出现问题,当下载的过程中,退出当前页面,下载会继续的,下载完成后继续运行你的代码打开文件进行预览,虽然你看不到这个过程,但是确实是这样的,而且会造成当前控制器无法释放,造成内存泄漏! ###解决办法: @property (nonatomic ,assign) BOOL isAppear; &#x2F;&#x2F;判断是否当前页面正在显示 - (void)viewWillDisappear:(BOOL)animated{ [super viewWillDisappear:animated]; self.isAppear &#x3D; NO; if (self.documentInteractionController) { self.documentInteractionController.delegate &#x3D; nil; NSLog(@”\\ndelegate &#x3D;&#x3D; nil\\n”); } } - (void)viewWillAppear:(BOOL)animated&#123; [super viewWillAppear:animated]; self.isAppear = YES; if (self.documentInteractionController) &#123; self.documentInteractionController.delegate = self; &#125; &#125; - ( void )setupDocumentControllerWithURL:( NSURL *)url &#123; if (!self.isAppear) &#123; return; &#125; if ( self.documentInteractionController == nil )&#123; self.documentInteractionController = [ UIDocumentInteractionController interactionControllerWithURL :url]; self.documentInteractionController.delegate = self ; &#125; else &#123; self.documentInteractionController.URL = url; &#125; &#125; - (void)documentInteractionControllerDidEndPreview:(UIDocumentInteractionController *)controller&#123; NSLog(@&quot;did end preview&quot;); self.documentInteractionController = nil; &#125; #这样就可以了!","categories":[],"tags":[]},{"title":"iOS 项目中加入 pch文件","slug":"code/iOS/iOS 项目中加入 pch文件","date":"2023-05-06T02:40:39.189Z","updated":"2023-05-04T20:28:17.000Z","comments":true,"path":"code/iOS/iOS 项目中加入 pch文件/","link":"","permalink":"https://blog.zaiyuan.cc/code/iOS/iOS%20%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%8A%A0%E5%85%A5%20pch%E6%96%87%E4%BB%B6/","excerpt":"","text":"1.创建pch文件 2.在pch文件中加入要全局使用的头文件 3.在工程中加入该pch文件 创建pch文件 直接创建,不改名字 打开该文件,添加需要全局使用的.h文件 在工程中加入该pch文件 1.查找位置,修改值为yes,如图 2.修改路径为: $(SRCROOT)&#x2F;Apartment&#x2F;PrefixHeader.pch ,其中Apartment为工程名,如图 3.编译 这样就可以在工程中全局使用了,喜欢的可以点个喜欢","categories":[],"tags":[]},{"title":"关于UIImagePickerController种种","slug":"code/iOS/关于UIImagePickerController种种","date":"2023-05-06T02:40:39.183Z","updated":"2023-05-04T20:26:24.000Z","comments":true,"path":"code/iOS/关于UIImagePickerController种种/","link":"","permalink":"https://blog.zaiyuan.cc/code/iOS/%E5%85%B3%E4%BA%8EUIImagePickerController%E7%A7%8D%E7%A7%8D/","excerpt":"","text":"###1设置照相机button为国际化在info.plist中设置 localized resources can be mixed 为 yes 即可 ###2让照片始终竖着朝向自己,不知道在win上面是否管用 UIImage *image &#x3D; info[@”UIImagePickerControllerOriginalImage”]; if (image.imageOrientation == UIImageOrientationLeft) &#123; image = [UIImage imageWithCGImage:image.CGImage scale:1 orientation:UIImageOrientationLeft]; &#125;else&#123; image = [UIImage imageWithCGImage:image.CGImage scale:1 orientation:UIImageOrientationRight]; &#125;","categories":[],"tags":[]},{"title":"关于push推送的种种","slug":"code/iOS/关于push推送的种种","date":"2023-05-06T02:40:39.178Z","updated":"2023-05-04T20:25:49.000Z","comments":true,"path":"code/iOS/关于push推送的种种/","link":"","permalink":"https://blog.zaiyuan.cc/code/iOS/%E5%85%B3%E4%BA%8Epush%E6%8E%A8%E9%80%81%E7%9A%84%E7%A7%8D%E7%A7%8D/","excerpt":"","text":"#1.后台推送过来的格式一般为 1234567891011&#123; &quot;aps&quot; : &#123; &quot;alert&quot; : &#123; &quot;body&quot; : &quot;Bob wants to play poker&quot;, //消息 &quot;action-loc-key&quot; : “PLAY&quot; &#125;, &quot;badge&quot; : 5, //显示在App左上角的角标数，代表未读消息，需要自己的服务进行统计和控制，apns不支持+1或者-1的操作。 &#125;, &quot;parm1&quot; : &quot;bar&quot;, //控制参数 &quot;parm2″ : [ &quot;bang&quot;, &quot;value&quot; ] //扩展参数 &#125; 这里要注意的时alert部分，它的值可以是一个String（文本消息），也可以是一个JSON的Dictionary。当它是文本消息的时候，系统就会把这些文字显示到一个alertview中；如果它也是由一个JSON Dictionary组成的话，其格式如下：1234action-loc-keyloc-keyloc-argslaunch-image body部分就是alertView中将要展现出来的文本消息，loc-属性主要是用来实现本地化消息，launch-image只是app主bundle里的一个图片文件的名称，一般来说我们不指定这一属性。 #####这么来的话就可以正常显示了,但是有一种问题,用户如果不点击这条消息,是无法回调到app里的#2.当程序在后台时不需要用户点击,可以直接回调到app里 让后台加上下列代码123456&#123; aps:&#123; content-available:1 alert:&#123;...&#125; &#125;&#125; 需要客户端打开后台模式 Remote notifications","categories":[],"tags":[]},{"title":"设置app iTunes可以查看沙盒路径下的文件","slug":"code/iOS/设置app iTunes可以查看沙盒路径下的文件","date":"2023-05-06T02:40:39.170Z","updated":"2023-05-04T20:25:02.000Z","comments":true,"path":"code/iOS/设置app iTunes可以查看沙盒路径下的文件/","link":"","permalink":"https://blog.zaiyuan.cc/code/iOS/%E8%AE%BE%E7%BD%AEapp%20iTunes%E5%8F%AF%E4%BB%A5%E6%9F%A5%E7%9C%8B%E6%B2%99%E7%9B%92%E8%B7%AF%E5%BE%84%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6/","excerpt":"","text":"设置info.plist Application supports iTunes file… &gt;&gt;&gt;&gt;&gt;&gt;&gt;YES #重点说明:开启此选项后,如果app并没有跟共享有关的功能,app会被拒绝!上线前请仔细检查","categories":[],"tags":[]},{"title":"DMKit   --- 4. DMSegmentView","slug":"code/iOS/DMKit   --- 4. DMSegmentView","date":"2023-05-06T02:40:39.166Z","updated":"2023-05-05T00:51:03.000Z","comments":true,"path":"code/iOS/DMKit   --- 4. DMSegmentView/","link":"","permalink":"https://blog.zaiyuan.cc/code/iOS/DMKit%20%20%20---%204.%20DMSegmentView/","excerpt":"","text":"DMKit 第四篇:DMSegmentView 开发iOS的时候经常用到的分段显示控制view 具体内容GitHub-DMKit DMSegmentView.h123456789/** frame&amp;views 必填 其他非必填 */- (instancetype)initWithFrame:(CGRect)frame views:(NSArray &lt;UIView *&gt; *)views //要显示的views titles:(NSArray &lt;NSString *&gt;*)titles //要显示的titles titleFont:(UIFont *)font //默认15 titleColor:(UIColor *)titleColor //默认黑色 titleSelectedColor:(UIColor *)selectedColor //默认绿色 titlesIsAverage:(BOOL)isAve //是否根据frameW平均显示titles,如果是:frameW不够显示的时候回用默认空白宽度 showAction:(void(^)(NSInteger index))showAction; //显示回调 个人觉得还是很好用的,喜欢的可以试一下,已经写好了demo想具体看看的请移驾:GitHub-DMKit","categories":[],"tags":[]},{"title":"DMKit   --- 3. UserInfo  单利","slug":"code/iOS/DMKit   --- 3. UserInfo  单利","date":"2023-05-06T02:40:39.116Z","updated":"2023-05-05T00:53:44.000Z","comments":true,"path":"code/iOS/DMKit   --- 3. UserInfo  单利/","link":"","permalink":"https://blog.zaiyuan.cc/code/iOS/DMKit%20%20%20---%203.%20UserInfo%20%20%E5%8D%95%E5%88%A9/","excerpt":"","text":"DMKit 第三篇:UserInfo 开发iOS的时候经常用到的用户信息单利 UserInfo 当中存储了用户的重要信息,使用单利模式存取更加方便,使用归档解档数据更加安全,并且把屏幕比例写到了这里–ui布局更加精确具体内容GitHub-DMKitUserInfo.h123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#import &lt;Foundation/Foundation.h&gt;@interface UserInfo : NSObject@property (nonatomic , copy) NSString *oldLoginStr;@property (nonatomic , copy) NSString *token;@property (nonatomic , assign) NSInteger userID;@property (nonatomic , copy) NSString *phoneNum; ///&lt;手机号@property (nonatomic , assign) double registTime; ///&lt;注册时间@property (nonatomic , copy) NSString *email; ///&lt;邮箱@property (nonatomic , copy) NSString *userName; ///&lt;用户名@property (nonatomic , copy) NSString *address; ///&lt;详细地址@property (nonatomic , copy) NSString *province; ///&lt;省@property (nonatomic , copy) NSString *city; ///&lt;市@property (nonatomic , copy) NSString *district; ///&lt;区@property (nonatomic , copy) NSString *password;@property (nonatomic , copy) NSString *headImg; ///&lt;头像@property (nonatomic , copy) NSString *headImgH; ///&lt;高清版头像+(instancetype) shareUser;/** 当用户登录了返回当前用户的token,如果是游客返回 &quot;tourist&quot; */+(NSString *)token;/** 写入文件 */-(void)saveDatas;/** 删除文件 */-(void)removeDatas;/** 清除个人数据 */-(void)clearDatas;/** 是否登录状态,根据token值动态计算 */-(BOOL)isLogin;//屏幕比例 根据6/6s/7的屏幕计算屏幕比例 配合DMDefine使用- (CGFloat)screenScale;- (CGFloat)screenScaleW;@end ###类扩展 12345678910#define kUserInfo @&quot;Userinfo&quot;static NSString * const kTourist = @&quot;tourist&quot;; ///&lt;游客token@interface UserInfo ()@property (nonatomic , assign) CGFloat scale;@property (nonatomic , assign) CGFloat scaleW;@end shareUser1234567891011121314151617+(instancetype) shareUser&#123; static UserInfo *userInfo; if (userInfo) &#123; return userInfo; &#125; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; NSString *filePath = [DMTools filePathInDocuntsWithFile:kUserInfo]; userInfo = [NSKeyedUnarchiver unarchiveObjectWithFile:filePath]; if (!userInfo) &#123; userInfo = [[self alloc] init]; &#125; &#125;); return userInfo;&#125; token 不推荐直接读取token,这样做我觉得更好1234+(NSString *)token&#123; return [UserInfo shareUser].token.length ? [UserInfo shareUser].token : kTourist;&#125; isLogin 不建议使用状态值来保存, 使用这种动态获取登录状态最好1234567-(BOOL)isLogin&#123; if (_token.length &gt; 0) &#123; return YES; &#125; return NO;&#125; 存取12345678910111213141516171819202122232425262728-(void)saveDatas&#123; NSString *filePath = [DMTools filePathInDocuntsWithFile:kUserInfo]; [NSKeyedArchiver archiveRootObject:self toFile:filePath];&#125;-(void)removeDatas&#123; //删除归档的文件 NSString *filePath = [DMTools filePathInDocuntsWithFile:kUserInfo]; [[NSFileManager defaultManager] removeItemAtPath:filePath error:nil];&#125;-(void)clearDatas&#123; self.token = @&quot;&quot;; self.phoneNum = nil; self.userID = 0; self.registTime = 0; self.email = nil; self.userName = nil; self.province = nil; self.city = nil; self.district = nil; self.address = nil; self.headImg = nil; self.headImgH = nil; [self saveDatas];&#125; 归档解档123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 解档协议方法 */- (instancetype)initWithCoder:(NSCoder *)coder&#123; self = [super init]; if (self) &#123; self.oldLoginStr = [coder decodeObjectForKey:@&quot;oldLoginStr&quot;]; self.token = [coder decodeObjectForKey:@&quot;token&quot;]; self.userID = [coder decodeIntegerForKey:@&quot;userID&quot;]; self.phoneNum = [coder decodeObjectForKey:@&quot;phoneNum&quot;]; self.registTime = [coder decodeDoubleForKey:@&quot;registTime&quot;]; self.email = [coder decodeObjectForKey:@&quot;email&quot;]; self.userName = [coder decodeObjectForKey:@&quot;userName&quot;]; self.address = [coder decodeObjectForKey:@&quot;address&quot;]; self.province = [coder decodeObjectForKey:@&quot;province&quot;]; self.city = [coder decodeObjectForKey:@&quot;city&quot;]; self.district = [coder decodeObjectForKey:@&quot;district&quot;]; self.headImg = [coder decodeObjectForKey:@&quot;headImg&quot;]; self.headImgH = [coder decodeObjectForKey:@&quot;headImgH&quot;]; self.password = [coder decodeObjectForKey:@&quot;password&quot;]; &#125; return self;&#125;/** * 归档协议方法 */-(void)encodeWithCoder:(NSCoder *)aCoder&#123; [aCoder encodeObject:_oldLoginStr forKey:@&quot;oldLoginStr&quot;]; [aCoder encodeObject:_token forKey:@&quot;token&quot;]; [aCoder encodeInteger:_userID forKey:@&quot;userID&quot;]; [aCoder encodeDouble:_registTime forKey:@&quot;registTime&quot;]; [aCoder encodeObject:_phoneNum forKey:@&quot;phoneNum&quot;]; [aCoder encodeObject:_email forKey:@&quot;email&quot;]; [aCoder encodeObject:_userName forKey:@&quot;userName&quot;]; [aCoder encodeObject:_address forKey:@&quot;address&quot;]; [aCoder encodeObject:_province forKey:@&quot;province&quot;]; [aCoder encodeObject:_city forKey:@&quot;city&quot;]; [aCoder encodeObject:_district forKey:@&quot;district&quot;]; [aCoder encodeObject:_headImg forKey:@&quot;headImg&quot;]; [aCoder encodeObject:_headImgH forKey:@&quot;headImgH&quot;]; [aCoder encodeObject:_password forKey:@&quot;password&quot;];&#125; Screen 屏幕比例 根据6&#x2F;6s&#x2F;7的屏幕计算屏幕比例 配合DMDefine使用,极力推荐这样使用,布局出来的东西跟ui给的图基本一模一样12345678910111213141516171819// kScale(123);// kScaleW(123);-(CGFloat)screenScale&#123; if (_scale == 0) &#123; _scale = kScreenH / 667.0f; &#125; return _scale;&#125;-(CGFloat)screenScaleW&#123; if (_scaleW == 0) &#123; _scaleW = kScreenW / 375.0f; &#125; return _scaleW;&#125; 想具体看看的请移驾:GitHub-DMKit","categories":[],"tags":[]},{"title":"DMKit   --- 2. DMTools 工具类","slug":"code/iOS/DMKit   --- 2. DMTools 工具类","date":"2023-05-06T02:40:39.112Z","updated":"2023-05-04T20:21:38.000Z","comments":true,"path":"code/iOS/DMKit   --- 2. DMTools 工具类/","link":"","permalink":"https://blog.zaiyuan.cc/code/iOS/DMKit%20%20%20---%202.%20DMTools%20%E5%B7%A5%E5%85%B7%E7%B1%BB/","excerpt":"","text":"#DMKit 第二篇:DMTools 开发iOS的时候经常用到的类方法##*这里只列出来头文件,具体内容GitHub-DMKit Alert &amp; Sheet &amp; Toast123456789101112131415161718192021222324252627/** 弹出对话框,只有确定按钮 */+ (void)showAlertWithTitle:(NSString *)title andContent:(NSString *)content andBlock:(void (^)())todo atController:(__weak UIViewController *)vc;/** 弹出对话框,带确定和取消按钮,可定制确定取消的标题 */+ (void)showAlertWithTitle:(NSString *)title andContent:(NSString *)content andSureBlock:(void(^)())sureTodo andCancelBlock:(void(^)())cancelTodo andSureTitle:(NSString *)sureTitle andCancelTitle:(NSString *)cancelTitle atController:(__weak UIViewController *)vc;/** 弹出sheet,根据数组弹出不同个数的action,外带取消按钮 */+(void)showSheetWithTitle:(NSString *)title andContent:(NSString *)content andActionTitles:(NSArray &lt;NSString*&gt; *)titles andBlock:(void (^)(int index))clickBlock atVC:(__weak UIViewController *)vc;/** 在window上显示toast */+ (void)showToastAtWindow:(NSString *)content;/** 在window上显示toast */+ (void)showToastAtWindow:(NSString *)content duration:(NSTimeInterval)time position:(id)obj; Tools123456789101112131415161718192021/** 检查一个对象是否为空 */+ (BOOL) checkIsNullObject:(id)anObject;/** 从一个nsobject中根据属性获得dict 目前只支持字符串类型*/+ (NSDictionary *) getDictFromObject:(NSObject *)object;/** 判断是否为中文简体 */+ (BOOL)isSimpleChinese;/** 判断是否为英文 */+ (BOOL)isEnglish;/** dict or array &gt;&gt;&gt;&gt;&gt; json */+ (NSString *)getJsonFromDictOrArray:(id)theData;/** jsonStr &gt;&gt;&gt;&gt;&gt;&gt;&gt; dict or array */+ (id) getDictOrArrayFromJsonStr:(NSString *)json;/** 根据起始数字 终点数字 和 持续时间 返回 每秒60次的播放数组 */+ (NSArray *)getNumsWithFrom:(CGFloat)from To:(CGFloat)to Time:(CGFloat)time; NSUserDefults12345678/** 存储用户偏好设置 到 NSUserDefults */+(void)saveUserData:(id &lt;NSCoding&gt;)data forKey:(NSString*)key;/** 读取用户偏好设置 */+(id)readUserDataForKey:(NSString*)key;/** 删除用户偏好设置*/+(void)removeUserDataForkey:(NSString*)key; Documents1234567891011121314151617181920/* 1、Documents 目录：您应该将所有de应用程序数据文件写入到这个目录下。这个目录用于存储用户数据或其它应该定期备份的信息。 2、AppName.app 目录：这是应用程序的程序包目录，包含应用程序的本身。由于应用程序必须经过签名，所以您在运行时不能对这个目录中的内容进行修改，否则可能会使应用程序无法启动。 3、Library 目录：这个目录下有两个子目录：Caches 和 Preferences Preferences 目录：包含应用程序的偏好设置文件。您不应该直接创建偏好设置文件，而是应该使用NSUserDefaults类来取得和设置应用程序的偏好. Caches 目录：用于存放应用程序专用的支持文件，保存应用程序再次启动过程中需要的信息。 4、tmp 目录：这个目录用于存放临时文件，保存应用程序再次启动过程中不需要的信息。 *//** 给出文件名获得其在doc中的路径 */+(NSString *)filePathInDocuntsWithFile:(NSString *)file;/** 给出文件名获得其在Cache中的路径 */+(NSString *)filePathInCachesWithFile:(NSString *)file;/** 给出文件名获得其在Tmp中的路径 */+(NSString *)filePathInTmpWithFile:(NSString *)file; FileManager1234567891011121314151617181920/** 文件是否存在 */+ (BOOL)fileExist:(NSString*)path;/** 目录是否存在 */+ (BOOL)directoryExist:(NSString*)dirPath;/** 创建目录 */+ (BOOL)createDirectory:(NSString*)dirPath;/** 删除指定路径文件 */+ (BOOL)deleteFileAtPath:(NSString *)filePath;/** 删除指定目录 */+ (BOOL)deleteDirectoryAtPath:(NSString *)dirPath;/** 给出imageName获得图片 Doc/Photos文件夹下 */+ (UIImage *)getImageWithImageName:(NSString *)imageName;/** 给出image和文件名,存储到Doc/Photos文件夹下 */+ (BOOL)writeImage:(UIImage *)image toFile:(NSString *)fileName; String1234567891011121314151617/** 字符串是否是空 */+ (BOOL)stringIsNull:(NSString *)string;/** 判断字符串是否全为空格 */+ (BOOL)stringIsAllWithSpace:(NSString *)string;/** 判断当前字符串跟数组里的字符串是否有相同的 */+ (BOOL) stringIsInArray:(NSArray *)array WithString:(NSString *)string;/** 计算文字所占位置大小 */+(CGRect) getRectByStr:(NSString *)str fontSize:(NSInteger )textSize maxW:(CGFloat)maxWidth maxH:(CGFloat)maxHeight;/** MD5 */+ (NSString *)MD5:(NSString *)string;/** 字符串转拼音 (没试过)*/+ (NSString *)stringToPinyinWithString:(NSString *)string; 正则匹配1234567891011121314151617/** 正则匹配邮箱号 */+ (BOOL)checkMailInput:(NSString *)mail;/** 正则匹配手机号 */+ (BOOL)checkTelNumber:(NSString *) telNumber;/** 正则匹配用户密码6-18位数字和字母组合 */+ (BOOL)checkPassword:(NSString *) password;/** 正则匹配密码(3-7位,必须为数字字母都存在,且只有数字字母) */+ (BOOL)checkPassword2:(NSString *)password;/** 正则匹配用户身份证号 */+ (BOOL)checkUserIdCard: (NSString *) idCard;/** 车牌号验证 */+ (BOOL) checkCarNumber:(NSString *) CarNumber; AFNetworking123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#pragma mark - &lt;&lt;AFNetWorking&gt;&gt;//Ajax--post提交/** 重用afn的post */+ (void)postWithUrl:(NSString *)url para:(id)para success:(void (^)(id responseObject))success failure:(void(^)(NSError *error))failure;/** 直接获取info 用于特定项目(项目中主要返回值内容全都跟在message里,并且是json型字符串) */+ (void)postWithUrl:(NSString *)url para:(id)para info:(void (^)(id info))infomation failure:(void(^)(NSError *error))failure;//Form表单提交, 模仿afn用法+ (void)postFormWithUrl:(NSString *)url para:(id)para success:(void (^)(id responseObject))success failure:(void(^)(NSError *error))failure;/** 直接获取message 用于特定项目*/+ (void)postFormWithUrl:(NSString *)url para:(id)para info:(void (^)(id info))infomation failure:(void(^)(NSError *error))failure;/** 重用afn的get */+ (void)getWithUrl:(NSString *)url para:(id)para success:(void (^)(id responseObject))success failure:(void(^)(NSError *error))failure;/** 直接获取message 用于特定项目 */+ (void)getWithUrl:(NSString *)url para:(id)para info:(void (^)(id info))infomation failure:(void(^)(NSError *error))failure;/** * 请求SOAP，返回NSData * * @param url 请求地址 * @param soapBody soap的XML中方法和参数段 * @param success 成功block * @param failure 失败block */+ (void)SOAPData:(NSString *)url funcName:(NSString *)funcName soapBody:(NSString *)soapBody success:(void (^)(id responseObject))success failure:(void(^)(NSError *error))failure; ##*常用第三方框架 在这里有些配合着使用 1234567AFNetworkingMBProgressHUDMasonryToastMJRefreshFMDBSDWebImage 想具体看看的请移驾:GitHub-DMKit","categories":[],"tags":[]},{"title":"DMKit   --- 1. DMDefine 宏定义","slug":"code/iOS/DMKit   --- 1. DMDefine 宏定义","date":"2023-05-06T02:40:39.108Z","updated":"2023-05-04T20:21:14.000Z","comments":true,"path":"code/iOS/DMKit   --- 1. DMDefine 宏定义/","link":"","permalink":"https://blog.zaiyuan.cc/code/iOS/DMKit%20%20%20---%201.%20DMDefine%20%E5%AE%8F%E5%AE%9A%E4%B9%89/","excerpt":"","text":"#DMKit 第一篇:DMDefine.h 开发iOS的时候经常用到的宏定义 ###NSLog 1234567891011#ifndef __OPTIMIZE__# define NSLog(...) NSLog(__VA_ARGS__)#else# define NSLog(...)#endif#ifdef DEBUG#define MyLog(...) NSLog(@&quot;%s 第%d行 \\n %@\\n\\n&quot;,__func__,__LINE__,[NSString stringWithFormat:__VA_ARGS__])#else#define MyLog(...)#endif ###Screen&#x2F;Frame 屏幕尺寸 123456789101112131415161718192021222324#define kScreenH [UIScreen mainScreen].bounds.size.height#define kScreenW [UIScreen mainScreen].bounds.size.width#define kLineH (1.0f / [UIScreen mainScreen].scale)//按比例设置view大小/字体大小等 这里要配合UserInfo单利使用#define kScale(value) ((value) * [UserInfo shareUser].screenScale)#define kScaleW(value) ((value) * [UserInfo shareUser].screenScaleW)#define kGetX(v) (v).frame.origin.x#define kGetY(v) (v).frame.origin.y#define kGetW(v) (v).frame.size.width#define kGetH(v) (v).frame.size.height#define kGetMinX(v) CGRectGetMinX((v).frame) // 获得控件屏幕的x坐标#define kGetMinY(v) CGRectGetMinY((v).frame) // 获得控件屏幕的Y坐标#define kGetMidX(v) CGRectGetMidX((v).frame) //横坐标加上到控件中点坐标#define kGetMidY(v) CGRectGetMidY((v).frame) //纵坐标加上到控件中点坐标#define kGetMaxX(v) CGRectGetMaxX((v).frame) //横坐标加上控件的宽度#define kGetMaxY(v) CGRectGetMaxY((v).frame) //纵坐标加上控件的高度#define kGetTextSize(text, font) [text length] &gt; 0 ? [text sizeWithAttributes:@&#123;NSFontAttributeName:font&#125;] : CGSizeZero //获取字体size 判断当前的iPhone设备&#x2F;系统版本123456789101112#define IS_IPHONE (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPhone)#define IS_IPAD (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)#define IS_IPOD ([[[UIDevice currentDevice] model] isEqualToString:@&quot;iPod touch&quot;])//获取系统版本#define IOS_SYSTEM_VERSION [[[UIDevice currentDevice] systemVersion] floatValue]//判断 iOS 8 或更高的系统版本#define IOS_VERSION_8_OR_LATER (([[[UIDevice currentDevice] systemVersion] floatValue] &gt;=8.0)? (YES):(NO))//获得app build号#define kAppBuild [[NSBundle mainBundle] objectForInfoDictionaryKey:(NSString *)kCFBundleVersionKey]//获得app Version 号#define kAppVerison [[NSBundle mainBundle] objectForInfoDictionaryKey:@&quot;CFBundleShortVersionString&quot;] Color123456789//快速获取颜色#define kGetColorRGB(r, g, b) [UIColor colorWithRed:(r)/255.0 green:(g)/255.0 blue:(b)/255.0 alpha:1.0]#define kGetColorRGBA(r, g, b, a) [UIColor colorWithRed:(r)/255.0 green:(g)/255.0 blue:(b)/255.0 alpha:a]#define kGetColorRgbValue(rgbValue) [UIColor colorWithRed:((float)((rgbValue &amp; 0xFF0000) &gt;&gt; 16))/255.0 green:((float)((rgbValue &amp; 0xFF00) &gt;&gt; 8))/255.0 blue:((float)(rgbValue &amp; 0xFF))/255.0 alpha:1.0]// 随机色#define kRandomColor [UIColor colorWithRed:arc4random_uniform(256)/255.0 green:arc4random_uniform(256)/255.0 blue:arc4random_uniform(256)/255.0 alpha:1.0] setValue:赋值的时候使用12345678910111213#define DM_STRING(object) (((object == nil) || ([object isEqual:[NSNull null]])) ? @&quot;&quot;:[NSString stringWithFormat:@&quot;%@&quot;, object])#define DM_INTEGER(object) ( ((object == nil) || ([object isEqual:[NSNull null]])) ? 0 : [object integerValue])#define DM_FLOAT(object) ( ((object == nil) || ([object isEqual:[NSNull null]])) ? 0.0f : [object floatValue])#define DM_DOUBLE(object) ( ((object == nil) || ([object isEqual:[NSNull null]])) ? 0.0f : [object doubleValue])#define DM_BOOL(object) ( ((object == nil) || ([object isEqual:[NSNull null]])) ? NO : [object boolValue])#define DM_ARRAY(object) ( ((object == nil) || ([object isEqual:[NSNull null]])) ? @[] : object )#define DM_DICTIONARY(object) ( ((object == nil) || ([object isEqual:[NSNull null]])) ? @&#123;&#125; : object ) Image12345678// 加载本地图片,不缓存#define kLoadImage(fileName,extName) [UIImage imageWithContentsOfFile:[[NSBundle mainBundle]pathForResource:fileName ofType:extName]]// 加载本地图片,缓存#define kGetImage(fileName) [UIImage imageNamed: fileName]// 加载xib#define kLoadView(className) [[NSBundle mainBundle] loadNibNamed:className owner:nil options:nil][0] G－C－D123456//后台线程运行#define BACK(block) dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), block)//主线程运行#define MAIN(block) dispatch_async(dispatch_get_main_queue(),block)//selfWeak#define WeakObj(self) __weak typeof(self) self##Weak = self; 国际化123456//获取字符串#define kLocStr(str) NSLocalizedString(str, nil)#define kLocStrTab(str,file) NSLocalizedStringFromTable(str, file, nil)//获取当前语言#define kCurrentLanguage [[NSLocale preferredLanguages] firstObject] #####自己用的大概就这么多吧,能应付一般的项目,把它放到pch里面,能使项目少写很多代码 #DMKit-GitHub:GitHub-DMKit","categories":[],"tags":[]},{"title":"iOS 关于启动页设置","slug":"code/iOS/iOS 关于启动页设置","date":"2023-05-06T02:40:39.105Z","updated":"2023-05-04T20:18:48.000Z","comments":true,"path":"code/iOS/iOS 关于启动页设置/","link":"","permalink":"https://blog.zaiyuan.cc/code/iOS/iOS%20%E5%85%B3%E4%BA%8E%E5%90%AF%E5%8A%A8%E9%A1%B5%E8%AE%BE%E7%BD%AE/","excerpt":"","text":"启动页默认Launch.storyboard想使用图片的: targets &gt;&gt; general &gt;&gt; launch images source &gt;&gt; create 进入 Assets.xcassets 设置刚才创建的LaunchImage 2.1 如图设置或自行按需设置 2.2 填入相应图片2.3 Landscape 是横屏的意思 进入info.plist 删除 Launch选项 这个尤为重要","categories":[],"tags":[]},{"title":"iOS 接收分享的文件  文件分享","slug":"code/iOS/iOS 接收分享的文件  文件分享","date":"2023-05-06T02:40:39.100Z","updated":"2023-05-04T20:16:04.000Z","comments":true,"path":"code/iOS/iOS 接收分享的文件  文件分享/","link":"","permalink":"https://blog.zaiyuan.cc/code/iOS/iOS%20%E6%8E%A5%E6%94%B6%E5%88%86%E4%BA%AB%E7%9A%84%E6%96%87%E4%BB%B6%20%20%E6%96%87%E4%BB%B6%E5%88%86%E4%BA%AB/","excerpt":"","text":"&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 分享文件 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ###效果图 主要代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152- (void)clickRightItem&#123; self.documentController = [UIDocumentInteractionController interactionControllerWithURL:[NSURL fileURLWithPath:_filePath]]; self.documentController.delegate = self; self.documentController.UTI = [self getUTI]; [self.documentController presentOpenInMenuFromRect:CGRectZero inView:self.view animated:YES];&#125;- (NSString *)getUTI&#123; NSString *typeStr = [self getFileTypeStr:_filePath.pathExtension]; if ([typeStr isEqualToString:@&quot;PDF&quot;]) &#123; return @&quot;com.adobe.pdf&quot;; &#125; if ([typeStr isEqualToString:@&quot;Word&quot;])&#123; return @&quot;com.microsoft.word.doc&quot;; &#125; if ([typeStr isEqualToString:@&quot;PowerPoint&quot;])&#123; return @&quot;com.microsoft.powerpoint.ppt&quot;; &#125; if ([typeStr isEqualToString:@&quot;Excel&quot;])&#123; return @&quot;com.microsoft.excel.xls&quot;; &#125; return @&quot;public.data&quot;;&#125;- (NSString *)getFileTypeStr:(NSString *)pathExtension&#123; if ([pathExtension isEqualToString:@&quot;pdf&quot;] || [pathExtension isEqualToString:@&quot;PDF&quot;]) &#123; return @&quot;PDF&quot;; &#125; if ([pathExtension isEqualToString:@&quot;doc&quot;] || [pathExtension isEqualToString:@&quot;docx&quot;] || [pathExtension isEqualToString:@&quot;DOC&quot;] || [pathExtension isEqualToString:@&quot;DOCX&quot;]) &#123; return @&quot;Word&quot;; &#125; if ([pathExtension isEqualToString:@&quot;ppt&quot;] || [pathExtension isEqualToString:@&quot;PPT&quot;]) &#123; return @&quot;PowerPoint&quot;; &#125; if ([pathExtension isEqualToString:@&quot;xls&quot;] || [pathExtension isEqualToString:@&quot;XLS&quot;]) &#123; return @&quot;Excel&quot;; &#125; return @&quot;其它&quot;;&#125; ###分享文件结束 End #&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; 接收文件 实现步骤 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;####1. 在info.plist 中新增key : CFBundleDocumentTypes 12345678910111213141516&lt;key&gt;CFBundleDocumentTypes&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;CFBundleTypeName&lt;/key&gt; &lt;string&gt;OFFICE Document&lt;/string&gt; &lt;key&gt;LSHandlerRank&lt;/key&gt; &lt;string&gt;Owner&lt;/string&gt; &lt;key&gt;LSItemContentTypes&lt;/key&gt; &lt;array&gt; &lt;string&gt;com.microsoft.word.doc&lt;/string&gt; &lt;string&gt;com.microsoft.powerpoint.ppt&lt;/string&gt; &lt;string&gt;com.microsoft.excel.xls&lt;/string&gt; &lt;string&gt;com.adobe.pdf&lt;/string&gt; &lt;/array&gt; &lt;/dict&gt; &lt;/array&gt; ######如图: 2. 在info.plist 中新增key : UTExportedTypeDeclarations1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;key&gt;UTExportedTypeDeclarations&lt;/key&gt; &lt;array&gt; &lt;dict&gt; &lt;key&gt;UTTypeConformsTo&lt;/key&gt; &lt;array&gt; &lt;string&gt;public.data&lt;/string&gt; &lt;string&gt;public.composite-content&lt;/string&gt; &lt;/array&gt; &lt;key&gt;UTTypeIdentifier&lt;/key&gt; &lt;string&gt;com.adobe.pdf&lt;/string&gt; &lt;key&gt;UTTypeDescription&lt;/key&gt; &lt;string&gt;PDF文档&lt;/string&gt; &lt;key&gt;UTTypeTagSpecification&lt;/key&gt; &lt;dict&gt; &lt;key&gt;public.mime-type&lt;/key&gt; &lt;string&gt;application/pdf&lt;/string&gt; &lt;key&gt;public.filename-extension&lt;/key&gt; &lt;array&gt; &lt;string&gt;pdf&lt;/string&gt; &lt;/array&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;UTTypeConformsTo&lt;/key&gt; &lt;array&gt; &lt;string&gt;public.data&lt;/string&gt; &lt;/array&gt; &lt;key&gt;UTTypeIdentifier&lt;/key&gt; &lt;string&gt;com.microsoft.word.doc&lt;/string&gt; &lt;key&gt;UTTypeDescription&lt;/key&gt; &lt;string&gt;Word文档&lt;/string&gt; &lt;key&gt;UTTypeTagSpecification&lt;/key&gt; &lt;dict&gt; &lt;key&gt;public.mime-type&lt;/key&gt; &lt;string&gt;application/msword&lt;/string&gt; &lt;key&gt;public.filename-extension&lt;/key&gt; &lt;array&gt; &lt;string&gt;doc&lt;/string&gt; &lt;string&gt;docx&lt;/string&gt; &lt;/array&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;dict&gt; &lt;key&gt;UTTypeConformsTo&lt;/key&gt; &lt;array&gt; &lt;string&gt;public.data&lt;/string&gt; &lt;/array&gt; &lt;key&gt;UTTypeIdentifier&lt;/key&gt; &lt;string&gt;com.microsoft.excel.xls&lt;/string&gt; &lt;key&gt;UTTypeDescription&lt;/key&gt; &lt;string&gt;Excel Document&lt;/string&gt; &lt;key&gt;UTTypeTagSpecification&lt;/key&gt; &lt;dict&gt; &lt;key&gt;public.mime-type&lt;/key&gt; &lt;string&gt;application/vnd.ms-excel&lt;/string&gt; &lt;key&gt;public.filename-extension&lt;/key&gt; &lt;array&gt; &lt;string&gt;xls&lt;/string&gt; &lt;/array&gt; &lt;/dict&gt; &lt;/dict&gt; &lt;/array&gt; 如图: 3. 在appdelegate中加入代码 接收文件, 并写入文件, 包括重名问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#pragma mark - &lt;&lt; ShareFile &gt;&gt;- (BOOL)application:(UIApplication *)app openURL:(nonnull NSURL *)url sourceApplication:(nullable NSString *)sourceApplication annotation:(nonnull id)annotation&#123; NSLog(@&quot;%@&quot;,url); NSLog(@&quot;%@&quot;,sourceApplication); NSString *typeStr = [self getFileTypeStr:url.path.pathExtension]; NSString *fileName = url.path.lastPathComponent; NSString *str = [NSString stringWithFormat:@&quot;文件类型: %@\\n文件名称: %@&quot;,typeStr,fileName]; [MyTools showAlertWithTitle:@&quot;您收到一个文件&quot; andContent:str andSureBlock:^&#123; NSData *data = [NSData dataWithContentsOfURL:url]; int result = [self writeFile:data toName:fileName writeType:0]; if (result == 0) &#123; [MyTools showToastAtWindow:@&quot;保存失败!&quot;]; &#125; else if (result == 1) &#123; [MyTools showToastAtWindow:@&quot;保存成功!&quot;]; &#125; else &#123; [MyTools showSheetWithTitle:[NSString stringWithFormat:@&quot;文件 %@ 已存在&quot;,fileName] andContent:@&quot;请选择操作&quot; andActionTitles:@[@&quot;替换&quot;,@&quot;保留两者&quot;] andBlock:^(int index) &#123; if (index == 0) &#123; int result1 = [self writeFile:data toName:fileName writeType:1]; if (result1 == 0) &#123; [MyTools showToastAtWindow:@&quot;保存失败!&quot;]; &#125; else if (result1 == 1) &#123; [MyTools showToastAtWindow:@&quot;保存成功!&quot;]; &#125; &#125; else &#123; int result1 = [self writeFile:data toName:fileName writeType:2]; if (result1 == 0) &#123; [MyTools showToastAtWindow:@&quot;保存失败!&quot;]; &#125; else if (result1 == 1) &#123; [MyTools showToastAtWindow:@&quot;保存成功!&quot;]; &#125; &#125; &#125; atVC:self.window.rootViewController]; &#125; &#125; andCancelBlock:nil andSureTitle:@&quot;保存&quot; andCancelTitle:@&quot;取消&quot; atController:self.window.rootViewController]; return YES;&#125;/** 写入文件 type: 0:尝试写入,如果重名返回重名 1:替换 2:重命名写入 return : 0:失败,1:成功,-1:有重名*/- (int)writeFile:(NSData *)data toName:(NSString *)name writeType:(int)type&#123; //生成文件夹路径 NSString *dirPath = [MyTools filePathInDocuntsWithFile:kDirShare]; //查看文件夹路径存在不,如果不存在创建文件夹,如果创建不成功返回no if (![MyTools directoryExist:dirPath]) &#123; if (![MyTools createDirectory:dirPath]) &#123; return 0; &#125; &#125; NSError *err = nil; NSArray *files = [[NSFileManager defaultManager] contentsOfDirectoryAtPath:dirPath error:&amp;err]; //判断是否有重名文件 NSLog(@&quot;%@&quot;,files); NSString *fileName = name; if ([MyTools stringIsInArray:files WithString:name]) &#123; if (type == 0) &#123; return -1; &#125; else if (type == 1) &#123; fileName = name; &#125; else &#123; fileName = [NSString stringWithFormat:@&quot;%@_%@.%@&quot;,name.stringByDeletingPathExtension,[DateTools stringFromDate:[NSDate date] withFormat:@&quot;yyyyMMddHHmmss&quot;],name.pathExtension]; &#125; &#125; //拼接路径 NSString *filePath = [dirPath stringByAppendingPathComponent:fileName]; return [data writeToFile:filePath atomically:YES];&#125;- (NSString *)getFileTypeStr:(NSString *)pathExtension&#123; if ([pathExtension isEqualToString:@&quot;pdf&quot;] || [pathExtension isEqualToString:@&quot;PDF&quot;]) &#123; return @&quot;PDF&quot;; &#125; if ([pathExtension isEqualToString:@&quot;doc&quot;] || [pathExtension isEqualToString:@&quot;docx&quot;] || [pathExtension isEqualToString:@&quot;DOC&quot;] || [pathExtension isEqualToString:@&quot;DOCX&quot;]) &#123; return @&quot;Word&quot;; &#125; if ([pathExtension isEqualToString:@&quot;ppt&quot;] || [pathExtension isEqualToString:@&quot;PPT&quot;]) &#123; return @&quot;PowerPoint&quot;; &#125; if ([pathExtension isEqualToString:@&quot;xls&quot;] || [pathExtension isEqualToString:@&quot;XLS&quot;]) &#123; return @&quot;Excel&quot;; &#125; return @&quot;其它&quot;;&#125; 至此接收文件结束参考文章: https://www.jianshu.com/p/19f5eff6b6ac https://stackoverflow.com/questions/15836145/associate-files-type-with-my-iphone-app 官方文档-参数列表","categories":[],"tags":[]},{"title":"iOS NSFileManager    小记","slug":"code/iOS/iOS NSFileManager    小记","date":"2023-05-06T02:40:39.095Z","updated":"2023-05-04T20:13:22.000Z","comments":true,"path":"code/iOS/iOS NSFileManager    小记/","link":"","permalink":"https://blog.zaiyuan.cc/code/iOS/iOS%20NSFileManager%20%20%20%20%E5%B0%8F%E8%AE%B0/","excerpt":"","text":"##遍历文件夹* 办法112345NSDirectoryEnumerator *enumer = [[NSFileManager defaultManager] enumeratorAtPath:dirPath];NSString *path;while (path = [enumer nextObject]) &#123; NSLog(@&quot;%@&quot;,path);&#125; ######遍历结果: 123419章新副本攻略-9.docgg修改教程-6.docxtest //文件夹test/test.png //文件夹下的文件 这样可以连文件夹带文件夹下的文件path一起读出来 * 办法21234567NSError *err = nil;NSArray *files = [[NSFileManager defaultManager] contentsOfDirectoryAtPath:dirPath error:&amp;err];if (err) &#123; NSLog(@&quot;%@&quot;,err);&#125; else &#123; NSLog(@&quot;%@&quot;,files);&#125; ######遍历结果: 12319章新副本攻略-9.doc,gg修改教程-6.docx,test //文件夹######能遍历出来文件夹,但是不遍历文件夹下的东西&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;","categories":[],"tags":[]},{"title":"iOS typedef NS_OPTIONS   枚举小记","slug":"code/iOS/iOS typedef NS_OPTIONS   枚举小记","date":"2023-05-06T02:40:39.092Z","updated":"2023-05-04T20:12:32.000Z","comments":true,"path":"code/iOS/iOS typedef NS_OPTIONS   枚举小记/","link":"","permalink":"https://blog.zaiyuan.cc/code/iOS/iOS%20typedef%20NS_OPTIONS%20%20%20%E6%9E%9A%E4%B8%BE%E5%B0%8F%E8%AE%B0/","excerpt":"","text":"1234567891011121314151617181920212223242526272829303132typedef NS_OPTIONS(NSUInteger, TestOptions) &#123; Option0 = 1 &lt;&lt; 0, //1 == 00000001 Option1 = 1 &lt;&lt; 1, //2 == 00000010 Option2 = 1 &lt;&lt; 2, //4 == 00000100 Option3 = 1 &lt;&lt; 3, //8 == 00001000 Option4 = 1 &lt;&lt; 4, //16 == 00010000 Option5 = 1 &lt;&lt; 5, //32 == 00100000 Option6 = 1 &lt;&lt; 6, //64 == 01000000 Option7 = 1 &lt;&lt; 7, //128 == 10000000&#125;;void test()&#123; NSLog(@&quot;%ld---%ld---%ld---%ld---%ld---%ld---%ld---%ld&quot;,Option0,Option1,Option2,Option3,Option4,Option5,Option6,Option7); NSUInteger option = Option2 | Option4 | Option6; //84 = 01010100 NSLog(@&quot;option : %ld&quot;,option); //84 = 01010100 NSLog(@&quot;%ld&quot;,option &amp; Option0); //0 NSLog(@&quot;%ld&quot;,option &amp; Option1); //0 NSLog(@&quot;%ld&quot;,option &amp; Option2); //4 01010100 &amp; 00000100 = 00000100 NSLog(@&quot;%ld&quot;,option &amp; Option3); //0 NSLog(@&quot;%ld&quot;,option &amp; Option4); //16 01010100 &amp; 00010000 = 00010000 NSLog(@&quot;%ld&quot;,option &amp; Option5); //0 NSLog(@&quot;%ld&quot;,option &amp; Option6); //64 NSLog(@&quot;%ld&quot;,option &amp; Option7); //0&#125;","categories":[],"tags":[]},{"title":"iOS UIImage  CIImage  CGImage  自己的理解","slug":"code/iOS/iOS UIImage  CIImage  CGImage  自己的理解","date":"2023-05-06T02:40:39.088Z","updated":"2023-05-04T20:10:43.000Z","comments":true,"path":"code/iOS/iOS UIImage  CIImage  CGImage  自己的理解/","link":"","permalink":"https://blog.zaiyuan.cc/code/iOS/iOS%20UIImage%20%20CIImage%20%20CGImage%20%20%E8%87%AA%E5%B7%B1%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"创建与使用1.使用imageWithCGImage 生成的图片 会重新生成UIImage 会把生成它的CGImageRef保存下来 并且img.CIImage为nil 可以生成NSData12345678910111213141516CGImageRef ref = img.CGImage;img = [UIImage imageWithCGImage:ref];if (ref == img.CGImage) &#123; NSLog(@&quot;把生成它的cgimg存下来了&quot;);&#125;if (!img.CIImage) &#123; NSLog(@&quot;ciimg == nil&quot;);&#125;//测试cgimg &gt;&gt; dataNSData *data = UIImagePNGRepresentation(img);if (data.length) &#123; NSLog(@&quot;cgimg &gt;&gt; uiimg &gt;&gt; data 成功!&quot;);&#125; else &#123; NSLog(@&quot;cgimg &gt;&gt; uiimg &gt;&gt; data 失败!&quot;);&#125; 2.使用imageWithCIImage 生成的图片 也会重新生成UIImage 同时会把生成它的CIImage存下来 img.CGImage &#x3D;&#x3D; NULL 生成NSData 为 nil12345678910111213141516CIImage *ciImg = [[CIImage alloc] initWithImage:img];img = [UIImage imageWithCIImage:ciImg];if (ciImg == img.CIImage) &#123; NSLog(@&quot;把生成它的ciimg存下来了&quot;);&#125;if (!img.CGImage) &#123; NSLog(@&quot;cgimg == NULL&quot;);&#125;//测试ciimg &gt;&gt; datadata = UIImagePNGRepresentation(img);if (data.length) &#123; NSLog(@&quot;ciimg &gt;&gt; uiimg &gt;&gt; data 成功!&quot;);&#125; else &#123; NSLog(@&quot;ciimg &gt;&gt; uiimg &gt;&gt; data 失败!&quot;);&#125;","categories":[],"tags":[]},{"title":"iOS CGBitMap 小计","slug":"code/iOS/iOS CGBitMap 小计","date":"2023-05-06T02:40:39.085Z","updated":"2023-05-04T20:09:54.000Z","comments":true,"path":"code/iOS/iOS CGBitMap 小计/","link":"","permalink":"https://blog.zaiyuan.cc/code/iOS/iOS%20CGBitMap%20%E5%B0%8F%E8%AE%A1/","excerpt":"","text":"创建context12345678CGBitmapContextCreate(&lt;#void * _Nullable data#&gt;, //指向要渲染的绘制内存的地址 &lt;#size_t width#&gt;, //width * scale &lt;#size_t height#&gt;, //height *scale &lt;#size_t bitsPerComponent#&gt;, //内存中像素的每个组件的位数 对于32位像素格式和RGB 颜色空间，你应该将这个值设为8 &lt;#size_t bytesPerRow#&gt;, //每一行在内存所占的比特数 &lt;#CGColorSpaceRef _Nullable space#&gt;, //上下文使用的颜色空间 &lt;#uint32_t bitmapInfo#&gt; //指定bitmap是否包含alpha通道，像素中alpha通道的相对位置，像素组件是整形还是浮点型等信息的字符串 ) 针对bitmapInfo字段做一些备注1. CGBitmapInfo 这个主要说一下kCGBitmapByteOrder32Little &#x2F; kCGBitmapByteOrder32Big kCGBitmapByteOrder32Little 生成的信息位置为: 倒序 kCGBitmapByteOrder32Big 生成的信息位置为: 顺序12345678910111213typedef CF_OPTIONS(uint32_t, CGBitmapInfo) &#123; kCGBitmapAlphaInfoMask = 0x1F, kCGBitmapFloatInfoMask = 0xF00, kCGBitmapFloatComponents = (1 &lt;&lt; 8), kCGBitmapByteOrderMask = kCGImageByteOrderMask, kCGBitmapByteOrderDefault = kCGImageByteOrderDefault, kCGBitmapByteOrder16Little = kCGImageByteOrder16Little, kCGBitmapByteOrder32Little = kCGImageByteOrder32Little, kCGBitmapByteOrder16Big = kCGImageByteOrder16Big, kCGBitmapByteOrder32Big = kCGImageByteOrder32Big&#125; CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0); 2. CGImageAlphaInfo 这个主要说一下 kCGImageAlphaPremultipliedLast &#x2F; kCGImageAlphaPremultipliedFirst kCGImageAlphaPremultipliedLast &gt;&gt;&gt;&gt; R G B A kCGImageAlphaPremultipliedFirst &gt;&gt;&gt;&gt; A R G B12345678910typedef CF_ENUM(uint32_t, CGImageAlphaInfo) &#123; kCGImageAlphaNone, /* For example, RGB. */ kCGImageAlphaPremultipliedLast, /* For example, premultiplied RGBA */ kCGImageAlphaPremultipliedFirst, /* For example, premultiplied ARGB */ kCGImageAlphaLast, /* For example, non-premultiplied RGBA */ kCGImageAlphaFirst, /* For example, non-premultiplied ARGB */ kCGImageAlphaNoneSkipLast, /* For example, RBGX. */ kCGImageAlphaNoneSkipFirst, /* For example, XRGB. */ kCGImageAlphaOnly /* No color data, alpha data only */&#125;; 说了这么多 举个栗子1234567891011121314151617181920212223242526272829//顺序 + argb = argbkCGImageByteOrder32Big | kCGImageAlphaPremultipliedFirst const int RED = 1;const int GREEN = 2;const int BLUE = 3;const int ALPHA = 0;//顺序 + rgba = rgbakCGImageByteOrder32Big | kCGImageAlphaPremultipliedLast const int RED = 0;const int GREEN =1;const int BLUE = 2;const int ALPHA = 3;//倒序 + rgba = abgrkCGImageByteOrder32Little | kCGImageAlphaPremultipliedLastconst int RED = 3;const int GREEN = 2;const int BLUE = 1;const int ALPHA = 0;//倒序 + argb = bgra;//kCGImageByteOrder32Little | kCGImageAlphaPremultipliedFirstconst int RED = 2;const int GREEN = 1;const int BLUE = 0;const int ALPHA = 3;","categories":[],"tags":[]},{"title":"iOS 性能分析小记","slug":"code/iOS/iOS 性能分析小记","date":"2023-05-06T02:40:39.082Z","updated":"2023-05-04T20:09:01.000Z","comments":true,"path":"code/iOS/iOS 性能分析小记/","link":"","permalink":"https://blog.zaiyuan.cc/code/iOS/iOS%20%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B0%8F%E8%AE%B0/","excerpt":"","text":"1.启动时间 1.1 main启动前时间测量: 通过环境变量,直接打印run &gt;&gt; arguments &gt;&gt; environment &gt;&gt; +号 Name: DYLD_PRINT_STATISTICSValue: 1 1.2 main之后通过计时打印时间main.m:12345678CFAbsoluteTime startTime;int main(int argc, char * argv[]) &#123; @autoreleasepool &#123; startTime = CFAbsoluteTimeGetCurrent(); return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class])); &#125;&#125; delegate.m: 12345678extern CFAbsoluteTime startTime;- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; NSLog(@&quot;startTime: %f s&quot;,CFAbsoluteTimeGetCurrent() - startTime); return YES;&#125; 2. 内存分析 2.1 weak 与 assign assign : __unsafe__unretained 引用的对象释放后,指针依然指向原地址weak : 引用对象释放后,指针指向nil 2.2 检测内存泄漏方法 静态分析 动态检测方法 (Instrument) 析构打印 第三方工具 (MLeaksFinder)","categories":[],"tags":[]},{"title":"ios   bitcode  and 生成.a","slug":"code/iOS/ios   bitcode  and 生成.a","date":"2023-05-06T02:40:39.080Z","updated":"2023-05-04T20:05:12.000Z","comments":true,"path":"code/iOS/ios   bitcode  and 生成.a/","link":"","permalink":"https://blog.zaiyuan.cc/code/iOS/ios%20%20%20bitcode%20%20and%20%E7%94%9F%E6%88%90.a/","excerpt":"","text":"bitcode 是必要的 用Clang编译成 ARM64 格式且带bitcode的目标文件test.o demo.o: wuqiong:~ apple$ xcrun -sdk iphoneos clang -arch arm64 -fembed-bitcode -c test.m demo.m 然后把两个目标文件打包为一个静态库文件:wuqiong:~ apple$ xcrun -sdk iphoneos ar -r libTest.a test.o demo.oar: creating archive libTest.a 用Shell命令otool查看目标文件中是否包含bitcode段:wuqiong:~ apple$ otool -l test.o |grep bitcode sectname __bitcode sectname __bitcode如果看到输出了2行sectname __bitcode,就是说明这静态库中的两个目标文件包含了bitcode.","categories":[],"tags":[]},{"title":"iOS 自己实现 名片识别  一   功能分析,模块划分","slug":"code/iOS/iOS 自己实现 名片识别  一   功能分析,模块划分","date":"2023-05-06T02:40:39.077Z","updated":"2023-05-04T19:57:21.000Z","comments":true,"path":"code/iOS/iOS 自己实现 名片识别  一   功能分析,模块划分/","link":"","permalink":"https://blog.zaiyuan.cc/code/iOS/iOS%20%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%20%E5%90%8D%E7%89%87%E8%AF%86%E5%88%AB%20%20%E4%B8%80%20%20%20%E5%8A%9F%E8%83%BD%E5%88%86%E6%9E%90,%E6%A8%A1%E5%9D%97%E5%88%92%E5%88%86/","excerpt":"","text":"1. iOS 自己实现 名片识别 一 功能分析,模块划分2. iOS 自己实现 名片识别 二 相机模块制作3. iOS 自己实现 名片识别 三 图片处理4. iOS 自己实现 名片识别 四 图片转文字以及归类 公司需求:要做一个名片识别,不能使用联网的那种第三方然后各种查资料,反编译,没有一个可以直接使用的,或者可以借鉴的,没办法,只能自己试着实现 1. 功能分析 总体来说,功能分为 图片转文字 , 文字归类 2. 模块划分 页面分为: 名片列表页 , 照相页 , 添加名片页 功能分布: 相机模块 , 照片处理模块 , 照片转文字模块 , 文字分类模块 相机模块功能: 相机展示 , 矩形检测 , 矩形展示 , 拍照 照片处理模块:4.1 裁剪4.2 矩形矫正4.3 灰度图4.4 提升亮度4.5 增加曝光4.6 高斯模糊4.7 增强文字轮廓4.8 二值化(二值化不会,利用了降低亮度,增加对比度,增加曝光来实现)4.9文字位置检测 , 裁剪 (文字位置检测与裁剪实现后,与不裁剪对比,明显不裁剪效果更好,所以把名片作为一个整体来识别了) 照片转文字模块: 检测照片中文字类别(中文?英文?),识别文字5.1 然而并不能检查出名片是中文还是英文,想法是好的,现实很残酷5.2 给出一个解决方案,识别两遍,看看哪个更理想就是哪个(我没有做处理)5.3 试图利用反编译看看&lt;&lt;名片全能王&gt;&gt;是怎么实现的,查看后他使用的库在网上查不到5.4 最终决定使用Google 的 Tesseract 进行图片转文字 文字分类模块 : 定义好类别,根据正则判断文字类别,归类6.1 这个模块完全没有参考,只能按照自己的思路慢慢写6.2 效果一般,不喜勿喷","categories":[],"tags":[]},{"title":"iOS 自己实现 名片识别  二      相机模块制作","slug":"code/iOS/iOS 自己实现 名片识别  二      相机模块制作","date":"2023-05-06T02:40:39.017Z","updated":"2023-05-04T19:55:24.000Z","comments":true,"path":"code/iOS/iOS 自己实现 名片识别  二      相机模块制作/","link":"","permalink":"https://blog.zaiyuan.cc/code/iOS/iOS%20%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%20%E5%90%8D%E7%89%87%E8%AF%86%E5%88%AB%20%20%E4%BA%8C%20%20%20%20%20%20%E7%9B%B8%E6%9C%BA%E6%A8%A1%E5%9D%97%E5%88%B6%E4%BD%9C/","excerpt":"","text":"1. iOS 自己实现 名片识别 一 功能分析,模块划分2. iOS 自己实现 名片识别 二 相机模块制作3. iOS 自己实现 名片识别 三 图片处理4. iOS 自己实现 名片识别 四 图片转文字以及归类 主题:相机模块制作 框架的选择与使用 1.1 相机功能 使用 AVFoundation 1.2 矩形检测: 由于AVFoundation 里面并没有矩形检 测,CoreImage中有矩形检测,Vision中也有矩形检测,但是Vision需要iOS11+才行,最终选中 CoreImage 框架来实现矩形检测 相机的使用2.1 展示到屏幕上2.2 实现代理获取到视频数据2.3 由于矩形的检测并不需要每一帧都去检测,所以我采取10帧检测一次的办法2.4 筛选最大矩形2.5 展示最大矩形2.6 点击拍照后,将照片与特征传入Result 效果 下面来看看具体实现####1. 代理的实现 12345678910111213141516171819202122232425262728- (void)captureOutput:(AVCaptureOutput *)output didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection&#123; // 实现10帧检测一次 static long count = 0; count ++; if (count % 10 != 0 ) &#123; return; &#125; //1. 生成CIImage CVImageBufferRef imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer); CIImage *ciimg = [CIImage imageWithCVImageBuffer:imageBuffer]; //2. 生成矩形特征数组 NSArray *rectFeatures = [self.detector featuresInImage:ciimg]; //3. 找出最大矩形 CIRectangleFeature *rectFeature = [self biggestRectInRects:rectFeatures]; NSLog(@&quot;%@---%@&quot;,NSStringFromCGRect(rectFeature.bounds) ,NSStringFromCGRect(ciimg.extent)); _currentImg = ciimg; _currentRectFeature = rectFeature; //4. 显示在屏幕上 [self showRectWithImg:ciimg feature:rectFeature];&#125; 2.从矩形数组中获取最大矩形1234567891011121314151617181920212223242526272829303132- (CIRectangleFeature *)biggestRectInRects:(NSArray *)rects&#123; if (rects.count == 0) &#123; return nil; &#125; if (rects.count == 1) &#123; return rects.firstObject; &#125; float halfPerimiterValue = 0; CIRectangleFeature *biggestRect = [rects firstObject]; for (CIRectangleFeature *rect in rects) &#123; CGPoint p1 = rect.topLeft; CGPoint p2 = rect.topRight; CGFloat width = hypotf(p1.x - p2.x, p1.y - p2.y); CGPoint p3 = rect.topLeft; CGPoint p4 = rect.bottomLeft; CGFloat height = hypotf(p3.x - p4.x, p3.y - p4.y); CGFloat currentHalfPerimiterValue = height + width; if (halfPerimiterValue &lt; currentHalfPerimiterValue) &#123; halfPerimiterValue = currentHalfPerimiterValue; biggestRect = rect; &#125; &#125; return biggestRect;&#125; 3.根据特征,屏幕上画出矩形123456789101112131415161718192021222324252627282930313233343536- (void)showRectWithImg:(CIImage *)img feature:(CIRectangleFeature *)rectFeature&#123; //当连续2次没有检测到矩形的时候 清楚屏幕上的矩形 static int rectIsNullCount = 0; if (rectFeature == nil) &#123; rectIsNullCount++; if (rectIsNullCount &gt;= 2) &#123; rectIsNullCount = 0; [self.rectView drawWithPointsfirst:CGPointZero second:CGPointZero thrid:CGPointZero forth:CGPointZero]; dispatch_async(dispatch_get_main_queue(), ^&#123; [self.rectView setNeedsDisplay]; &#125;); return; &#125; return; &#125; rectIsNullCount = 0; //检测到矩形,计数清零 CGRect previewRect = self.rect; CGRect imageRect = img.extent; CGFloat scaleW = CGRectGetWidth(previewRect) / CGRectGetHeight(imageRect); CGFloat scaleH = CGRectGetHeight(previewRect) / CGRectGetWidth(imageRect); // 由于ciimage 与屏幕 是旋转90度的,所有需要进行调校和等比例缩放才能画出点 [self.rectView drawWithPointsfirst:CGPointMake(rectFeature.topLeft.y * scaleW, rectFeature.topLeft.x * scaleH) second:CGPointMake(rectFeature.topRight.y * scaleW, rectFeature.topRight.x * scaleH) thrid:CGPointMake(rectFeature.bottomRight.y * scaleW, rectFeature.bottomRight.x * scaleH) forth:CGPointMake(rectFeature.bottomLeft.y * scaleW, rectFeature.bottomLeft.x * scaleH)]; dispatch_async(dispatch_get_main_queue(), ^&#123; [self.rectView setNeedsDisplay]; &#125;);&#125;","categories":[],"tags":[{"name":"code","slug":"code","permalink":"https://blog.zaiyuan.cc/tags/code/"},{"name":"ios","slug":"ios","permalink":"https://blog.zaiyuan.cc/tags/ios/"}]},{"title":"iOS 自己实现 名片识别  三   图片处理","slug":"code/iOS/iOS 自己实现 名片识别  三   图片处理","date":"2023-05-06T02:40:39.008Z","updated":"2023-05-04T19:38:48.000Z","comments":true,"path":"code/iOS/iOS 自己实现 名片识别  三   图片处理/","link":"","permalink":"https://blog.zaiyuan.cc/code/iOS/iOS%20%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%20%E5%90%8D%E7%89%87%E8%AF%86%E5%88%AB%20%20%E4%B8%89%20%20%20%E5%9B%BE%E7%89%87%E5%A4%84%E7%90%86/","excerpt":"","text":"1. iOS 自己实现 名片识别 一 功能分析,模块划分2. iOS 自己实现 名片识别 二 相机模块制作3. iOS 自己实现 名片识别 三 图片处理4. iOS 自己实现 名片识别 四 图片转文字以及归类主题: 图片处理声明:下面这些图片仅供学习使用 1.剪切图片 根据矩形特征剪切图片 1234// @property (nonatomic , strong) CIImage *img;//@property (nonatomic , strong) CIRectangleFeature *feature;_img = [_img imageByCroppingToRect:_feature.bounds]; 2.图形矫正根据特征修正图片 , 这一步很重要 , 是否做这一步直接影响识别精度 1234567NSDictionary *para = @&#123; @&quot;inputTopLeft&quot;: [CIVector vectorWithCGPoint:_feature.topLeft], @&quot;inputTopRight&quot;: [CIVector vectorWithCGPoint:_feature.topRight], @&quot;inputBottomLeft&quot;: [CIVector vectorWithCGPoint:_feature.bottomLeft], @&quot;inputBottomRight&quot;: [CIVector vectorWithCGPoint:_feature.bottomRight] &#125;; _img = [_img imageByApplyingFilter:@&quot;CIPerspectiveCorrection&quot; withInputParameters:para]; 3. 灰度处理主要用来做文字识别所以直接去掉色彩信息 1234CIColor *filterInputcolor = [CIColor colorWithRed:0.75 green:0.75 blue:0.75];//只有在主动设置的时候才丢弃颜色信息//CIColorMonochrome 单色滤镜_img = [_img imageByApplyingFilter:@&quot;CIColorMonochrome&quot; withInputParameters:@&#123;kCIInputColorKey : filterInputcolor&#125;]; 4.提升亮度会损失一部分背景纹理 饱和度不能太高 12345678NSDictionary *para = @&#123; kCIInputSaturationKey : @(0.35), //饱和度 kCIInputBrightnessKey : @(0.2), //亮度 kCIInputContrastKey : @(1.1) //对比度 &#125;;//CIColorControls 调整饱和度、亮度和对比度值_img = [_img imageByApplyingFilter:@&quot;CIColorControls&quot; withInputParameters:para]; 5. 曝光调节1_img = [_img imageByApplyingFilter:@&quot;CIExposureAdjust&quot; withInputParameters:@&#123;kCIInputEVKey : @(0.65)&#125;]; 6.高斯模糊查资料的时候都推荐这个,不过看不懂有什么用 1_img = [_img imageByApplyingGaussianBlurWithSigma:0.4]; 7.增强文字轮廓(描边)123456 NSDictionary* para = @&#123; kCIInputRadiusKey : @(2.5), //获取或设置要检测的最小要素的半径。 kCIInputIntensityKey : @(0.5), //获取或设置增强对比度的强度 &#125;;_img = [_img imageByApplyingFilter:@&quot;CIUnsharpMask&quot; withInputParameters:para]; 8.调低亮度,增加对比度使图片字体更黑 12345678NSDictionary *para = @&#123; kCIInputSaturationKey : @(0.35), //饱和度 kCIInputBrightnessKey : @(-0.7), //亮度 kCIInputContrastKey : @(1.9) //对比度 &#125;;//CIColorControls 调整饱和度、亮度和对比度值_img = [_img imageByApplyingFilter:@&quot;CIColorControls&quot; withInputParameters:para]; 9.增加曝光使上一步调黑的背景变白 1_img = [_img imageByApplyingFilter:@&quot;CIExposureAdjust&quot; withInputParameters:@&#123;kCIInputEVKey : @(0.65)&#125;]; ##至此图片的处理已经完成,剩下的就交给识别模块了 文字位置检测 , 裁剪 (文字位置检测与裁剪实现后,与不裁剪对比,明显不裁剪效果更好,所以把名片作为一个整体来识别了)","categories":[],"tags":[{"name":"code","slug":"code","permalink":"https://blog.zaiyuan.cc/tags/code/"},{"name":"ios","slug":"ios","permalink":"https://blog.zaiyuan.cc/tags/ios/"}]},{"title":"iOS 自己实现 名片识别  四  图片转文字以及归类","slug":"code/iOS/iOS 自己实现 名片识别  四  图片转文字以及归类","date":"2023-05-06T02:40:39.002Z","updated":"2023-05-04T19:29:42.000Z","comments":true,"path":"code/iOS/iOS 自己实现 名片识别  四  图片转文字以及归类/","link":"","permalink":"https://blog.zaiyuan.cc/code/iOS/iOS%20%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%20%E5%90%8D%E7%89%87%E8%AF%86%E5%88%AB%20%20%E5%9B%9B%20%20%E5%9B%BE%E7%89%87%E8%BD%AC%E6%96%87%E5%AD%97%E4%BB%A5%E5%8F%8A%E5%BD%92%E7%B1%BB/","excerpt":"","text":"1. iOS 自己实现 名片识别 一 功能分析,模块划分2. iOS 自己实现 名片识别 二 相机模块制作3. iOS 自己实现 名片识别 三 图片处理4. iOS 自己实现 名片识别 四 图片转文字以及归类本页主题: 图片转文字以及归类 先看效果展示 原图: 处理后: OCR识别效果: 123456789101112量 U::; 愧睡酣苒 `:| . -@ 唧涮区 总 代埋í倪礼波经理展厅: 西部家具城南海厅B217号电话: 15031600991 13473605996 / 义-〉15319986681 归类后的效果: 123456789组织 : 量 U地址 : 西部家具城南海厅B217号姓名 : 倪礼波职位 : 经理Phone : 15031600991Phone : 13473605996Phone : 15319986681Other : 愧睡酣苒 |Other : @ 唧涮区 总 代埋 效果还行,但达不到商用的目标 实现过程 1. 接入OCR模块这一过程比较复杂,网上也都能查到 2. 图片转文字1234567891011- (void)tesseractRecognizeImage:(UIImage *)image compleate:(void (^)(NSString *text))compleate &#123; dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0), ^&#123; G8Tesseract *tesseract = [[G8Tesseract alloc] initWithLanguage:@&quot;chi_sim&quot;]; tesseract.engineMode = G8OCREngineModeTesseractOnly; tesseract.image = image; [tesseract recognize]; //执行回调 compleate(tesseract.recognizedText); &#125;);&#125; 3. 文字归类这一块也比较复杂,我制作了中文的归类 去除没用的字符 NSArray *array &#x3D; @[@”:”,@”-“,@”&quot;“,@”~”,@”&#x2F;“,@”」”,@”;”,@”ˉ”,@”&#96;”,@”‘“,@”¢”,@”±”,@”‘“,@”_”]; 将字符串按行转换为数组 进行关键字筛选 : 电话,邮箱,qq,web, 地址 把每一行都进行筛选, 筛选成功后删除该行 检查姓名与职位 (需要用到两张表, 我这里使用了两个txt文件代替表) 检测job ,如果job有多余,多余的部分可能为姓名,如果多余的部分不是姓名 则为job的一部分 如果第一行还没有被使用，那么假设第一个标记是组织名称。 如果地址还没有,检查地址 &#x2F;&#x2F;检查地址的关键字,有两个或者两个以上关键字则标记为地址@[@”省”,@”市”,@”区”,@”路”,@”大厦”,@”号”,@”城”,@”室”,@”街”]; 根据正则重新过滤一遍 web,phone,email,qq 列一下正则 123456789101112131415161718192021222324252627282930/** 邮箱 */- (NSString *)emailRegex&#123; return @&quot;\\\\w[-\\\\w.+]*@([A-Za-z0-9][-A-Za-z0-9]+\\\\.)+[A-Za-z]&#123;2,14&#125;&quot;;&#125;/** 手机 */- (NSString *)phoneNumRegex&#123; return @&quot;0?(13|14|15|17|18|19)[0-9]&#123;9&#125;&quot;; //国内手机号&#125;/** 电话 */- (NSString *)telRegex&#123; return @&quot;[0-9-()（）]&#123;7,18&#125;&quot;;&#125;/** web */- (NSString *)webRegex&#123; return @&quot;^((https|http|ftp|rtsp|mms)?:\\\\/\\\\/)[^\\\\s]+&quot;;&#125;/** qq */- (NSString *)qqRegex&#123; return @&quot;[1-9]([0-9]&#123;5,11&#125;)&quot;;&#125; 剩余的则标记为other THE END !由于ocr模块比较大,需要代码的小伙伴可以留下联系方式,或者直接与我联系:QQ 258141764 发现需要代码的人还是挺多的,为了方便传到了百度网盘链接:https://pan.baidu.com/s/17LsXgbe3XuOiv9V4sVTVVQ 密码:dzk2需要的请自行下载! 代码所在位置: 如果觉得内容对你有所帮助,请帮忙点赞支持,让更多的人看到","categories":[],"tags":[]},{"title":"DMKit - DMKit","slug":"code/iOS/DMKit - DMKit","date":"2023-05-06T02:40:38.989Z","updated":"2023-05-04T19:25:36.000Z","comments":true,"path":"code/iOS/DMKit - DMKit/","link":"","permalink":"https://blog.zaiyuan.cc/code/iOS/DMKit%20-%20DMKit/","excerpt":"","text":"https://github.com/liu5855019/DMKitPods DMKit —&gt; 一个综合的框架1. Tools文件&#x2F;类 | 注释:——- | :——-DMDefine.h | 常用宏定义DMTools | 常用工具类DMLanguageTool | 语言国际化LocationTool | 常用获取地理位置工具ImagePickerTool | 常用选择照片工具(相机&#x2F;相册) 2. DMBase文件&#x2F;类 | 注释:——-: | :——-DMBaseViewController | DMBaseViewControllerDMBaseNavigationController | DMBaseNavigationController 3. DMCategory文件&#x2F;类 | 注释:——- | :——-NSArray+DMTools | 对数组的扩展UIViewController | 对VC的扩展UINavigationBar | 对导航栏的扩展CADisplayLink | 对displayLink的扩展NSData | 加入Aes的支持,并且加入对Hash的支持包括Hmac(参考了YYKit)NSDate | _NSObject | _NSString | 这个比较庞杂,同样加入Hash和Aes,同时还有其他UIColor | _UIImage | _UILabel | _ 4. DMView文件&#x2F;类 | 注释:——- | :——-DMBaseAlertView | _DMBasePickerView | _DMPickerView.h | _DMDatePickerView.h | _DMItemsView.h | _DMSegmentView.h | _DMShowBigImageView.h | _DMShadowView.h | _DMWebView.h | _DMWKWebView.h | _","categories":[],"tags":[{"name":"code","slug":"code","permalink":"https://blog.zaiyuan.cc/tags/code/"},{"name":"ios","slug":"ios","permalink":"https://blog.zaiyuan.cc/tags/ios/"}]},{"title":"iOS 13 强制白色模式","slug":"code/iOS/iOS 13 强制白色模式","date":"2023-05-06T02:40:38.986Z","updated":"2023-05-04T19:01:07.000Z","comments":true,"path":"code/iOS/iOS 13 强制白色模式/","link":"","permalink":"https://blog.zaiyuan.cc/code/iOS/iOS%2013%20%E5%BC%BA%E5%88%B6%E7%99%BD%E8%89%B2%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"在 AppDelegate 中 加入如下代码:12345if (@available(iOS 13.0, *)) &#123; self.window.overrideUserInterfaceStyle = UIUserInterfaceStyleLight;&#125; else &#123; &#125; 2.需要在info.plist文件中添加User Interface Style配置, 并设置为Light 12&lt;key&gt;UIUserInterfaceStyle&lt;/key&gt;&lt;string&gt;Light&lt;/string&gt;","categories":[],"tags":[{"name":"code","slug":"code","permalink":"https://blog.zaiyuan.cc/tags/code/"},{"name":"ios","slug":"ios","permalink":"https://blog.zaiyuan.cc/tags/ios/"}]},{"title":"代码 与 \"遗传学\" \"进化论\"","slug":"code/iOS/代码 与 _遗传学_ _进化论_","date":"2023-05-06T02:40:38.984Z","updated":"2023-05-04T18:59:34.000Z","comments":true,"path":"code/iOS/代码 与 _遗传学_ _进化论_/","link":"","permalink":"https://blog.zaiyuan.cc/code/iOS/%E4%BB%A3%E7%A0%81%20%E4%B8%8E%20_%E9%81%97%E4%BC%A0%E5%AD%A6_%20_%E8%BF%9B%E5%8C%96%E8%AE%BA_/","excerpt":"","text":"前言前几天我看了一篇文章, 讲的就是这个, 深有感触, 于是自己用代码撸了一遍 先讲故事 (故事是根据之前的文章写的) 有一块沙滩, 上面住着很多的贝壳 , 贝壳的壳上有着各种的图案. 有一天村民发现了这里, 开始捡贝壳回家…, 贝壳跟村民回家后的待遇大伙们都懂… 但是村民不是什么贝壳都捡, 村民家里有信仰的图腾, 当发现贝壳的图案与图腾比较像的时候就跳过, 村民会留下一部分让贝壳们繁衍生息 就这样过了 n 代以后 , 你会发现每个贝壳的壳上都长着与图腾很像的图案. 故事讲完了, 这就是 遗传学 进化论 的神奇之处 , 下来我用代码来模拟这一过程 定义123456789101112131415/// 种群最大数let populationMaxCount = 100;/// 种群被筛选后剩余最小数let populationMinCount = 30;/// 每个 unit 特征个数let unitDNACount = 100;/// 突变概率, 20 代表 20% , 即: 生成model会产生突变的概率;let mutationRate = 60;/// 算法按 相同 算还是 相似 算let isEqualCount = true;/// 输出结果是按 线 输出还是按 点 输出let isDrawLine = false; 主要循环 :繁衍生息 &gt;&gt; 排序 &gt;&gt; 剔除不像的 &gt;&gt; 输出最像的 &gt;&gt; 是否继续 &gt;&gt; 繁衍生息 12345678910func runLoop(block:(_ datas:[HeredityModel] , _ times:Int)-&gt;Bool) &#123; var isGoOn = true; while isGoOn &#123; makeChilds(); sort(); weedOut(); times += 1; isGoOn = block(datas,times); &#125; &#125; 繁衍生息 当少于种群最大值时就繁殖 在剩余种群中 找出一对父母 进行繁育 1234567891011121314151617// 繁衍生息 func makeChilds() &#123; while datas.count &lt; populationMaxCount - 1 &#123; birthChild(); &#125; &#125; // 造人 func birthChild() &#123; let half = populationMinCount / 2; let mother = datas[Int(arc4random()) % half]; // 前半数组中取一个 let father = datas[Int(arc4random()) % half + half]; // 后半数组中取一个 let child = HeredityModel(father, mother); child.makeLikeCount(base: baseModel); datas.append(child); &#125; 造物过程 取父与母的随机一个 DNA 进行遗传 (遗传学中 DNA 是根据显性与隐性来遗传的, 代码中就用随机来代表了) 根据概率计算其是否需要变异 (没有变异, 物种就不会进化) 随机计算要进化的 DNA 的位置 123456789101112131415init(_ model1:HeredityModel ,_ model2:HeredityModel) &#123; let isMutation = arc4random() % 100 &lt; mutationRate; //是否进行突变 let index = isMutation ? Int(arc4random()) % unitDNACount : -1; // 突变位置 for i in 0...unitDNACount-1 &#123; if i == index &#123; // 突变 models.append(HereditySubModel()); &#125; else &#123; // 正常遗传 let random = arc4random() % 2; let model = random == 1 ? model2 : model1; models.append(model.models[i]); &#125; &#125;&#125; 相似度计算 基准 DNA 我是画了一条45°的直线 按 DNA 相似计算 (物种会很快取向相似 , 并且越来越相似) 按 DNA 相同计算 (物种多样性会更好 , 很久以后也存在跳脱的) 1234567891011121314func makeLikeCount(base:HeredityModel) &#123; likeCount = 0; for i in 0...unitDNACount-1 &#123; if isEqualCount &#123; // 按基因相同计算 if (self.models[i].x == base.models[i].x &amp;&amp; self.models[i].y == base.models[i].y) &#123; likeCount += 1; &#125; &#125; else &#123; // 按基因相似计算 likeCount += unitDNACount - abs(self.models[i].x - base.models[i].x); likeCount += unitDNACount - abs(self.models[i].y - base.models[i].y); &#125; &#125; &#125; 成果展示 基准 DNA 我是画了一条45°的直线 按 DNA 相似计算 经过 98239 代繁育 , 终于进化出完美的 DNA 按 DNA 相同计算 总共繁衍了 100000 代 , 在 85555 代的时候已经繁衍出相同数 99 的物种了 ,最终也没有进化出完美的 , 并不是说这种进化不出 , 只是运气问题而已 总结通过调整 定义值 , 会有不同的变化 , 通过这些变化可以看到 进化论 中很多神奇的进化过程 .喜欢的同学可以自己下载演示: 源码地址 &#x2F;&#x2F; MacOS代码","categories":[],"tags":[{"name":"code","slug":"code","permalink":"https://blog.zaiyuan.cc/tags/code/"},{"name":"ios","slug":"ios","permalink":"https://blog.zaiyuan.cc/tags/ios/"}]},{"title":"dotnet 依赖注入相关知识点","slug":"code/dotnet/dotnet 依赖注入相关知识点","date":"2023-05-06T02:40:38.953Z","updated":"2023-05-04T22:38:41.000Z","comments":true,"path":"code/dotnet/dotnet 依赖注入相关知识点/","link":"","permalink":"https://blog.zaiyuan.cc/code/dotnet/dotnet%20%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E7%82%B9/","excerpt":"","text":"AddTransient瞬时模式：每次请求，都获取一个新的实例。即使同一个请求获取多次也会是不同的实例AddScoped：每次请求，都获取一个新的实例。同一个请求获取多次会得到相同的实例AddSingleton单例模式：每次都获取同一个实例","categories":[],"tags":[]},{"title":"dotnet Guid to 16进制字符串","slug":"code/dotnet/dotnet Guid to 16进制字符串","date":"2023-05-06T02:40:38.950Z","updated":"2023-05-04T22:38:08.000Z","comments":true,"path":"code/dotnet/dotnet Guid to 16进制字符串/","link":"","permalink":"https://blog.zaiyuan.cc/code/dotnet/dotnet%20Guid%20to%2016%E8%BF%9B%E5%88%B6%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"123Guid guid = Guid.NewGuid();var id = BitConverter.ToString(guid.ToByteArray()).Replace(&quot;-&quot;, &quot;&quot;);Console.WriteLine(id);","categories":[],"tags":[]},{"title":"dotnet Attribute","slug":"code/dotnet/dotnet Attribute","date":"2023-05-06T02:40:38.946Z","updated":"2023-05-04T22:37:15.000Z","comments":true,"path":"code/dotnet/dotnet Attribute/","link":"","permalink":"https://blog.zaiyuan.cc/code/dotnet/dotnet%20Attribute/","excerpt":"","text":"1234567891011121314151617// 只有在 debug 模式下才运行[Conditional(&quot;DEBUG&quot;)]public void newFunc()&#123; Console.WriteLine(&quot;new func&quot;);&#125;// 当调用 oldFunc 的时候会报警告已弃用[Obsolete(&quot;This is old func, please use new func&quot;)]// 同上[Obsolete(&quot;This is old func, please use new func&quot;,false)]// 当调用的时候直接报错误[Obsolete(&quot;This is old func, please use new func&quot;,true)]public void oldFunc()&#123; Console.WriteLine(&quot;old func&quot;);&#125; 下面这篇文章写得非常好, 我就不再写了好文在此1好文在此2","categories":[],"tags":[]},{"title":"dotnet EF Code First 数据库同步","slug":"code/dotnet/dotnet EF Code First 数据库同步","date":"2023-05-06T02:40:38.943Z","updated":"2023-05-04T22:36:11.000Z","comments":true,"path":"code/dotnet/dotnet EF Code First 数据库同步/","link":"","permalink":"https://blog.zaiyuan.cc/code/dotnet/dotnet%20EF%20Code%20First%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%90%8C%E6%AD%A5/","excerpt":"","text":"DBContext 所需包: 1234Microsoft.EntityFrameworkCoreMicrosoft.EntityFrameworkCore.DesignMicrosoft.EntityFrameworkCore.SqlServerMicrosoft.EntityFrameworkCore.Tools program 所需包: 1Microsoft.EntityFrameworkCore.Design 1. 写好 DBContext 配置 ConnectionString 配置 DbSet&lt;&gt;1234567891011121314151617181920212223242526272829303132public class DaimuDbContext : DbContext&#123; public readonly string connectionString; public DaimuDbContext() : this(null) &#123; &#125; public DaimuDbContext(string ConnectionString) &#123; if (ConnectionString == null || ConnectionString.Length == 0) &#123; //Configuration connectionString = &quot;ConnectionString&quot;; &#125; else &#123; connectionString = ConnectionString; &#125; &#125; protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder) &#123; if (optionsBuilder != null) &#123; optionsBuilder.UseSqlServer(connectionString); &#125; &#125; public DbSet&lt;UserInfo&gt; UserInfo &#123; get; set; &#125; public DbSet&lt;OrderInfo&gt; OrderInfo &#123; get; set; &#125;&#125; 2. 在 Startup 中注入12345public void ConfigureServices(IServiceCollection services)&#123; services.AddGrpc(); services.AddDbContext&lt;DaimuDbContext&gt;();&#125; 3. 打开 NuGet 命令行 , 并选择 DBContext 文件所在目录4. 输入命令 , 生成 migration 文件1add-migration &lt;&lt;#name#&gt;&gt; 5. 输入命令, 同步到数据库1update-database &lt;&lt;#name#&gt;&gt;","categories":[],"tags":[]},{"title":"dotnet Oracle 调用存储过程","slug":"code/dotnet/dotnet Oracle 调用存储过程","date":"2023-05-06T02:40:38.940Z","updated":"2023-05-04T22:34:50.000Z","comments":true,"path":"code/dotnet/dotnet Oracle 调用存储过程/","link":"","permalink":"https://blog.zaiyuan.cc/code/dotnet/dotnet%20Oracle%20%E8%B0%83%E7%94%A8%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B/","excerpt":"","text":"Type1. 使用 OracleConnection 调用12345678910111213141516171819public void test(string connectStr)&#123; using (OracleConnection connection = new OracleConnection(connectStr)) &#123; connection.Open(); OracleCommand sqlCmd = new OracleCommand(&quot;GETSEQUENCE&quot;, connection); OracleParameter[] parameters = new OracleParameter[2]; parameters[0] = new OracleParameter(&quot;:SEQ_NAME&quot;, OracleDbType.Varchar2) &#123; Value = &quot;SEQ&quot;, Direction = System.Data.ParameterDirection.Input &#125;; parameters[1] = new OracleParameter(&quot;:SEQ_VALUE&quot;, OracleDbType.Int32) &#123; Direction = System.Data.ParameterDirection.Output &#125;; sqlCmd.Parameters.AddRange(parameters); sqlCmd.CommandType = CommandType.StoredProcedure;//设置 使用存储过程 sqlCmd.ExecuteNonQuery(); int obj = Convert.ToInt32(parameters[1].Value.ToString()); connection.Close(); System.Console.WriteLine(obj); &#125; &#125; Type2. 使用EF123456789101112131415161718public int test(string connectStr)&#123; var ParaSeqName = new OracleParameter(&quot;SEQ_NAME&quot;, OracleDbType.Varchar2, SeqName, ParameterDirection.Input); var ParaSeqValue = new OracleParameter(&quot;SEQ_VALUE&quot;, OracleDbType.Int32, ParameterDirection.Output); var strSQL = &quot;BEGIN GETSEQUENCE(:SEQ_NAME,:SEQ_VALUE); END;&quot;; var result = base.DbContext.Database.ExecuteSqlCommand(strSQL, ParaSeqName, ParaSeqValue); if (result != -1) &#123; _logger.LogError($&quot;End; Orcacle error code:&#123;result&#125;&quot;); return 0; &#125; OracleDecimal ret = (OracleDecimal)ParaSeqValue.Value; Int32 orderNo = ret.IsNull ? 0 : ret.ToInt32(); return orderNo;&#125;","categories":[],"tags":[]},{"title":"dotnet gRpc 客户端配置","slug":"code/dotnet/dotnet gRpc 客户端配置","date":"2023-05-06T02:40:38.936Z","updated":"2023-05-04T22:33:17.000Z","comments":true,"path":"code/dotnet/dotnet gRpc 客户端配置/","link":"","permalink":"https://blog.zaiyuan.cc/code/dotnet/dotnet%20gRpc%20%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%85%8D%E7%BD%AE/","excerpt":"","text":"1. 包依赖 (使用 nuget 安装)Grpc.AspNetCore 2. 复制 proto 文件3. 在项目文件中加入:123&lt;ItemGroup&gt; &lt;Protobuf Include=&quot;Protos\\greet.proto&quot; GrpcServices=&quot;Client&quot;/&gt;&lt;/ItemGroup&gt;","categories":[],"tags":[]},{"title":"dotnet 利用表达式进行类型转换","slug":"code/dotnet/dotnet 利用表达式进行类型转换","date":"2023-05-06T02:40:38.930Z","updated":"2023-05-04T22:30:45.000Z","comments":true,"path":"code/dotnet/dotnet 利用表达式进行类型转换/","link":"","permalink":"https://blog.zaiyuan.cc/code/dotnet/dotnet%20%E5%88%A9%E7%94%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%9B%E8%A1%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"主要思想: 两个不同的类进行映射 利用for循环找到相同的属性 利用表达式把属性的赋值过程给存下来生成 表达式list 真正使用的时候, 只需要读取表达式list进行赋值就好 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391namespace Common&#123; using NLog; using System; using System.Collections; using System.Collections.Generic; using System.Linq; using System.Linq.Expressions; public static class Mapper&lt;TSource, TDestination&gt; where TSource : class where TDestination : class, new() &#123; private static readonly ILogger Logger = LogManager.GetCurrentClassLogger(); private static readonly Type[] NotReferenceType = new Type[] &#123; typeof(Google.Protobuf.WellKnownTypes.Timestamp) &#125;; public readonly static Func&lt;TSource, TDestination&gt; MapperFunc = GetMapperFunc(); public readonly static Action&lt;TSource, TDestination&gt; MapperAction = GetMapperAction(); public static TDestination MapTo(TSource source, Action&lt;TSource, TDestination&gt; action = null) &#123; if (source == null) &#123; Logger.Warn(&quot;The parameter (&#x27;source&#x27;) cannot be null.&quot;); return null; &#125; var target = MapperFunc(source); action?.Invoke(source, target); return target; &#125; public static List&lt;TDestination&gt; MapToList(IEnumerable&lt;TSource&gt; sources, Action&lt;TSource, TDestination&gt; action = null) &#123; if (sources == null) &#123; Logger.Error($&quot;The parameter (&#x27;sources&#x27;) cannot be null.&quot;); throw new ArgumentNullException($&quot;The parameter(&#x27;sources&#x27;) cannot be null.&quot;); &#125; var list = new List&lt;TDestination&gt;(); foreach (var item in sources) &#123; list.Add(MapTo(item, action)); &#125; return list; &#125; #region Private Method private static Func&lt;TSource, TDestination&gt; GetMapperFunc() &#123; return source =&gt; &#123; var target = new TDestination(); MapperAction(source, target); return target; &#125;; &#125; private static Action&lt;TSource, TDestination&gt; GetMapperAction() &#123; //获取源类型和指向类型 var sourceType = typeof(TSource); var destinationType = typeof(TDestination); //创建Expression参数 var sourceParameter = Expression.Parameter(sourceType, &quot;x&quot;); var destinationParameter = Expression.Parameter(destinationType, &quot;p&quot;); //创建Expression集合 var expressionList = new List&lt;Expression&gt;(); //获取TDestination中的所有允许写入权限的Public属性 或 RepeatedField 属性 var destinationProperties = destinationType.GetProperties() .Where(x =&gt; (x.PropertyType.IsPublic || x.PropertyType.IsNestedPublic) &amp;&amp; (x.CanWrite || x.PropertyType.FullName.Contains(typeof(Google.Protobuf.Collections.RepeatedField&lt;&gt;).FullName))); var sourceProperties = sourceType.GetProperties() .Where(x =&gt; x.PropertyType.IsPublic || x.PropertyType.IsNestedPublic); foreach (var destinationPropertyInfo in destinationProperties) &#123; try &#123; //获取匹配的TSource Property var sourcePropertyInfo = sourceProperties.FirstOrDefault(x =&gt; string.Compare(x.Name, destinationPropertyInfo.Name) == 0); if (sourcePropertyInfo == null || !sourcePropertyInfo.CanRead || sourcePropertyInfo.PropertyType.IsNotPublic) &#123; continue; &#125; //创建访问属性的表达式 var sourceProperty = Expression.Property(sourceParameter, sourcePropertyInfo); var destinationProperty = Expression.Property(destinationParameter, destinationPropertyInfo); //TSource Property不是值类型，并且和TDestination Property不相同 if (!sourcePropertyInfo.PropertyType.IsValueType &amp;&amp; !NotReferenceType.Contains(sourcePropertyInfo.PropertyType) &amp;&amp; sourcePropertyInfo.PropertyType != destinationPropertyInfo.PropertyType &amp;&amp; sourcePropertyInfo.PropertyType != typeof(string) &amp;&amp; destinationPropertyInfo.PropertyType != typeof(string)) &#123; //TSource Property和TDestination Property都是Class if (sourcePropertyInfo.PropertyType.IsClass &amp;&amp; destinationPropertyInfo.PropertyType.IsClass &amp;&amp; !sourcePropertyInfo.PropertyType.IsArray &amp;&amp; !destinationPropertyInfo.PropertyType.IsArray &amp;&amp; !sourcePropertyInfo.PropertyType.IsGenericType &amp;&amp; !destinationPropertyInfo.PropertyType.IsGenericType) &#123; var expression = GetClassExpression(sourceProperty, sourcePropertyInfo.PropertyType, destinationPropertyInfo.PropertyType); expressionList.Add(Expression.Assign(destinationProperty, expression)); continue; &#125; //TSource派生自IEnumerable，TDestination类型为RepeatedField //从C#IEnumerable转到Google ProtoBuffers RepeatedField if (typeof(IEnumerable).IsAssignableFrom(sourcePropertyInfo.PropertyType) &amp;&amp; destinationPropertyInfo.PropertyType.FullName.Contains(typeof(Google.Protobuf.Collections.RepeatedField&lt;&gt;).FullName)) &#123; var test = Expression.NotEqual(sourceProperty, Expression.Constant(null, sourcePropertyInfo.PropertyType)); //获取List泛型参数 var sourceArgument = sourcePropertyInfo.PropertyType.IsArray ? sourcePropertyInfo.PropertyType.GetElementType() : sourcePropertyInfo.PropertyType.GetGenericArguments()[0]; var destinationArgument = sourcePropertyInfo.PropertyType.IsArray ? destinationPropertyInfo.PropertyType.GetElementType() : destinationPropertyInfo.PropertyType.GetGenericArguments()[0]; //构建方法主体 var mapperType = typeof(Mapper&lt;,&gt;).MakeGenericType(sourceArgument, destinationArgument); var actionType = typeof(Action&lt;,&gt;).MakeGenericType(sourceArgument, destinationArgument); var methodCall = Expression.Call(mapperType.GetMethod(nameof(MapToList) , new Type[] &#123; sourcePropertyInfo.PropertyType, actionType &#125;) , sourceProperty , Expression.Constant(null, actionType)); //构建p.columns.addrange(maptolist(x.columns, null)) var repeatedFieldType = typeof(Google.Protobuf.Collections.RepeatedField&lt;&gt;) .MakeGenericType(destinationArgument); var callExpression = Expression.Call( destinationProperty , repeatedFieldType.GetMethod(&quot;AddRange&quot;) , methodCall); var exp = Expression.IfThen(test, callExpression); expressionList.Add(exp); continue; &#125; //TSource 派生自 RepeatedField，TDestination 类型为 IEnumerable //从 Google ProtoBuffers RepeatedField 转到 C#IEnumerable if (sourcePropertyInfo.PropertyType.FullName.Contains(typeof(Google.Protobuf.Collections.RepeatedField&lt;&gt;).FullName) &amp;&amp; typeof(IEnumerable).IsAssignableFrom(destinationPropertyInfo.PropertyType)) &#123; var test = Expression.NotEqual(sourceProperty, Expression.Constant(null, sourcePropertyInfo.PropertyType)); //获取List泛型参数 var sourceArgument = destinationPropertyInfo.PropertyType.IsArray ? sourcePropertyInfo.PropertyType.GetElementType() : sourcePropertyInfo.PropertyType.GetGenericArguments()[0]; var destinationArgument = destinationPropertyInfo.PropertyType.IsArray ? destinationPropertyInfo.PropertyType.GetElementType() : destinationPropertyInfo.PropertyType.GetGenericArguments()[0]; //构建方法主体 var mapperType = typeof(Mapper&lt;,&gt;).MakeGenericType(sourceArgument, destinationArgument); var actionType = typeof(Action&lt;,&gt;).MakeGenericType(sourceArgument, destinationArgument); var methodCall = Expression.Call(mapperType.GetMethod(nameof(MapToList) , new Type[] &#123; sourcePropertyInfo.PropertyType, actionType &#125;) , sourceProperty , Expression.Constant(null, actionType)); var result = Expression.Assign(destinationProperty, methodCall); expressionList.Add(Expression.IfThen(test, result)); continue; &#125; //TSource 和 TDestination都是直接或间接派生自IEnumerable if (typeof(IEnumerable).IsAssignableFrom(sourcePropertyInfo.PropertyType) &amp;&amp; typeof(IEnumerable).IsAssignableFrom(destinationPropertyInfo.PropertyType)) &#123; var expression = GetEnumerableExpression(sourceProperty, sourcePropertyInfo.PropertyType, destinationPropertyInfo.PropertyType); expressionList.Add(Expression.Assign(destinationProperty, expression)); continue; &#125; &#125; //可空类型转换到非可空类型，当可空类型值为null时，用默认值赋给目标属性；不为null就直接转换 else if (IsNullable(sourcePropertyInfo.PropertyType) &amp;&amp; !IsNullable(destinationPropertyInfo.PropertyType)) &#123; var hasValueExpression = Expression.Equal(Expression.Property(sourceProperty, &quot;HasValue&quot;), Expression.Constant(true)); //C# DateTime?类型转换到ProtoBuffers TimeStamp if (sourcePropertyInfo.PropertyType.FullName.Contains(typeof(DateTime).FullName) &amp;&amp; destinationPropertyInfo.PropertyType.FullName.Contains(typeof(Google.Protobuf.WellKnownTypes.Timestamp).FullName)) &#123; var timestampType = typeof(Google.Protobuf.WellKnownTypes.Timestamp); var valueExpression = Expression.Condition(hasValueExpression, Expression.Convert(sourceProperty,typeof(DateTime)), Expression.Default(typeof(DateTime))); var callExpression = Expression.Call(valueExpression, typeof(DateTime).GetMethod(&quot;ToUniversalTime&quot;)); var call = Expression.Call(timestampType.GetMethod(&quot;FromDateTime&quot;, new Type[] &#123; typeof(DateTime) &#125;), callExpression); var conditionDateTime = Expression.Condition(hasValueExpression, call, Expression.Default(destinationPropertyInfo.PropertyType)); expressionList.Add(Expression.Assign(destinationProperty, conditionDateTime)); &#125; else &#123; var condition = Expression.Condition(hasValueExpression, Expression.Convert(sourceProperty, destinationPropertyInfo.PropertyType), Expression.Default(destinationPropertyInfo.PropertyType)); expressionList.Add(Expression.Assign(destinationProperty, condition)); &#125; continue; &#125; //非可空类型转换到可空类型，直接转换 else if (!IsNullable(sourcePropertyInfo.PropertyType) &amp;&amp; IsNullable(destinationPropertyInfo.PropertyType)) &#123; var memberExpression = Expression.Convert(sourceProperty, destinationPropertyInfo.PropertyType); expressionList.Add(Expression.Assign(destinationProperty, memberExpression)); continue; &#125; //ProtoBuffers TimeStamp类型转换到C# DateTime类型 else if (sourcePropertyInfo.PropertyType.FullName.Contains(typeof(Google.Protobuf.WellKnownTypes.Timestamp).FullName) &amp;&amp; destinationPropertyInfo.PropertyType.FullName.Contains(typeof(DateTime).FullName)) &#123; var timestampType = typeof(Google.Protobuf.WellKnownTypes.Timestamp); //var callExpression = Expression.Call(timestampType, nameof(Google.Protobuf.WellKnownTypes.Timestamp.ToDateTime), new Type[] &#123; timestampType &#125;, sourceProperty) var callExpression = Expression.Call(sourceProperty, timestampType.GetMethod(&quot;ToDateTime&quot;)); expressionList.Add(Expression.Assign(destinationProperty, callExpression)); continue; &#125; //C# DateTime类型转换到ProtoBuffers TimeStamp else if (sourcePropertyInfo.PropertyType.FullName.Contains(typeof(DateTime).FullName) &amp;&amp; destinationPropertyInfo.PropertyType.FullName.Contains(typeof(Google.Protobuf.WellKnownTypes.Timestamp).FullName)) &#123; var timestampType = typeof(Google.Protobuf.WellKnownTypes.Timestamp); var callExpression = Expression.Call(sourceProperty, typeof(DateTime).GetMethod(&quot;ToUniversalTime&quot;)); var call = Expression.Call(timestampType.GetMethod(&quot;FromDateTime&quot;, new Type[] &#123; typeof(DateTime) &#125;), callExpression); expressionList.Add(Expression.Assign(destinationProperty, call)); continue; &#125; //String 转换 Guid else if (sourcePropertyInfo.PropertyType.FullName.Contains(typeof(string).FullName) &amp;&amp; destinationPropertyInfo.PropertyType.FullName.Contains(typeof(Guid).FullName)) &#123; var call = Expression.Call(typeof(Guid).GetMethod(&quot;Prase&quot;, new Type[] &#123; typeof(string) &#125;), sourceProperty); expressionList.Add(Expression.Assign(destinationProperty, call)); continue; &#125; else if (sourcePropertyInfo.PropertyType.FullName.Contains(typeof(string).FullName) &amp;&amp; destinationPropertyInfo.PropertyType.FullName.Contains(typeof(string).FullName)) &#123; var test = Expression.NotEqual(sourceProperty, Expression.Constant(null, sourcePropertyInfo.PropertyType)); var ifThenExp = Expression.IfThen(test, Expression.Assign(destinationProperty, sourceProperty)); expressionList.Add(ifThenExp); continue; &#125; // Enum else if (sourcePropertyInfo.PropertyType.IsEnum &amp;&amp; destinationPropertyInfo.PropertyType.IsEnum) &#123; var convertExpression = Expression.Convert(sourceProperty, destinationPropertyInfo.PropertyType); expressionList.Add(Expression.Assign(destinationProperty, convertExpression)); continue; &#125; else if (sourcePropertyInfo.PropertyType != destinationPropertyInfo.PropertyType) &#123; continue; &#125; var assignExpression = Expression.Assign(destinationProperty, sourceProperty); expressionList.Add(assignExpression); &#125; catch(ArgumentNullException ex) &#123; Logger.Error(ex); throw new ArgumentNullException(ex.Message, ex); &#125; catch(ArgumentException ex) &#123; Logger.Error(ex); throw new ArgumentException(ex.Message, ex); &#125; catch (Exception ex) &#123; Logger.Error(ex); throw new InvalidOperationException(ex.Message, ex); &#125; &#125; //当TDestination ！= null，判断TSource是否为null var testSource = Expression.NotEqual(sourceParameter, Expression.Constant(null, sourceType)); var ifTrueSource = Expression.Block(expressionList); var conditionSource = Expression.IfThen(testSource, ifTrueSource); //判断TDestination是否为空 var testTarget = Expression.NotEqual(destinationParameter, Expression.Constant(null, destinationType)); var conditionTarget = Expression.IfThen(testTarget, conditionSource); var lambda = Expression.Lambda&lt;Action&lt;TSource, TDestination&gt;&gt;(conditionTarget, sourceParameter, destinationParameter); return lambda.Compile(); &#125; private static Expression GetClassExpression(Expression sourceExpression, Type sourcePropertyType, Type destinationPropertyType) &#123; try &#123; var test = Expression.NotEqual(sourceExpression, Expression.Constant(null, sourcePropertyType)); //构建方法主体 var mapperManagerType = typeof(Mapper&lt;,&gt;).MakeGenericType(sourcePropertyType, destinationPropertyType); var actionType = typeof(Action&lt;,&gt;).MakeGenericType(sourcePropertyType, destinationPropertyType); var ifTrue = Expression.Call(mapperManagerType.GetMethod(nameof(MapTo), new Type[] &#123; sourcePropertyType, actionType &#125;), sourceExpression, Expression.Constant(null, actionType)); var ifFalse = Expression.Constant(null, destinationPropertyType); var condition = Expression.Condition(test, ifTrue, ifFalse); return condition; &#125; catch (Exception ex) &#123; Logger.Error(ex); throw new ArgumentException(ex.Message, ex); &#125; &#125; private static Expression GetEnumerableExpression(Expression sourceExpression, Type sourcePropertyType, Type destinationPropertyType) &#123; try &#123; var test = Expression.NotEqual(sourceExpression, Expression.Constant(null, sourcePropertyType)); //获取List泛型参数 var sourceArgument = sourcePropertyType.IsArray ? sourcePropertyType.GetElementType() : sourcePropertyType.GetGenericArguments()[0]; var destinationArgument = sourcePropertyType.IsArray ? destinationPropertyType.GetElementType() : sourcePropertyType.GetGenericArguments()[0]; //构建方法主体 var mapperManagerType = typeof(Mapper&lt;,&gt;).MakeGenericType(sourceArgument, destinationArgument); var actionType = typeof(Action&lt;,&gt;).MakeGenericType(sourceArgument, destinationArgument); var methodCall = Expression.Call(mapperManagerType.GetMethod(nameof(MapToList), new Type[] &#123; sourcePropertyType, actionType &#125;), sourceExpression, Expression.Constant(null, sourcePropertyType)); Expression ifTrue; if (destinationPropertyType.Equals(methodCall.Type)) &#123; ifTrue = methodCall; &#125; else if (destinationPropertyType.IsArray) &#123; //数组，获取泛型TSource，调用ToArray方法转化 ifTrue = Expression.Call(typeof(Enumerable), nameof(Enumerable.ToArray), new[] &#123; methodCall.Type.GenericTypeArguments[0] &#125;, methodCall); &#125; else if (typeof(IDictionary).IsAssignableFrom(destinationPropertyType)) &#123; //字典，获取泛型TSource，调用ToDictionary方法转化 ifTrue = Expression.Call(typeof(Enumerable), nameof(Enumerable.ToDictionary), new[] &#123; methodCall.Type.GenericTypeArguments[0] &#125;, methodCall); &#125; else &#123; ifTrue = Expression.Convert(methodCall, destinationPropertyType); &#125; var ifFlase = Expression.Constant(null, destinationPropertyType); var conditionItem = Expression.Condition(test, ifTrue, ifFlase); return conditionItem; &#125; catch (Exception ex) &#123; Logger.Error(ex); throw new ArgumentException(ex.Message, ex); &#125; &#125; private static bool IsNullable(Type type) &#123; return type.IsGenericType &amp;&amp; type.GetGenericTypeDefinition().Equals(typeof(Nullable&lt;&gt;)); &#125; #endregion &#125;&#125;","categories":[],"tags":[{"name":"dotnet","slug":"dotnet","permalink":"https://blog.zaiyuan.cc/tags/dotnet/"}]},{"title":"dotnet -- 5. 中间件 Middleware","slug":"code/dotnet/dotnet -- 5. 中间件 Middleware","date":"2023-05-06T02:40:38.925Z","updated":"2023-05-05T01:23:59.000Z","comments":true,"path":"code/dotnet/dotnet -- 5. 中间件 Middleware/","link":"","permalink":"https://blog.zaiyuan.cc/code/dotnet/dotnet%20--%205.%20%E4%B8%AD%E9%97%B4%E4%BB%B6%20Middleware/","excerpt":"","text":"概念 地址: https://learn.microsoft.com/zh-cn/aspnet/core/fundamentals/middleware/?view=aspnetcore-7.0 常用中间件 异常&#x2F;错误处理 当应用在开发环境中运行时： 开发人员异常页中间件 (UseDeveloperExceptionPage) 报告应用运行时错误。 数据库错误页中间件 (UseDatabaseErrorPage) 报告数据库运行时错误。 当应用在生产环境中运行时： 异常处理程序中间件 (UseExceptionHandler) 捕获以下中间件中引发的异常。 HTTP 严格传输安全协议 (HSTS) 中间件 (UseHsts) 添加 Strict-Transport-Security 标头。 HTTPS 重定向中间件 (UseHttpsRedirection) 将 HTTP 请求重定向到 HTTPS。 静态文件中间件 (UseStaticFiles) 返回静态文件，并简化进一步请求处理。 Cookie 策略中间件 (UseCookiePolicy) 使应用符合欧盟一般数据保护条例 (GDPR) 规定。 用于路由请求的路由中间件 (UseRouting)。 身份验证中间件 (UseAuthentication) 尝试对用户进行身份验证，然后才会允许用户访问安全资源。 用于授权用户访问安全资源的授权中间件 (UseAuthorization)。 会话中间件 (UseSession) 建立和维护会话状态。 如果应用使用会话状态，请在 Cookie 策略中间件之后和 MVC 中间件之前调用会话中间件。 用于将 Razor Pages 终结点添加到请求管道的终结点路由中间件（带有 MapRazorPages 的 UseEndpoints）。123456789101112131415161718if (env.IsDevelopment())&#123; app.UseDeveloperExceptionPage(); app.UseDatabaseErrorPage();&#125;else&#123; app.UseExceptionHandler(&quot;/Error&quot;); app.UseHsts();&#125;app.UseHttpsRedirection();app.UseStaticFiles();app.UseCookiePolicy();app.UseRouting();app.UseAuthentication();app.UseAuthorization();app.UseSession();app.MapRazorPages();","categories":[],"tags":[{"name":"dotnet","slug":"dotnet","permalink":"https://blog.zaiyuan.cc/tags/dotnet/"},{"name":".netcore","slug":"netcore","permalink":"https://blog.zaiyuan.cc/tags/netcore/"}]},{"title":"dotnet -- 4. set 跨域 Cors","slug":"code/dotnet/dotnet -- 4. set 跨域 Cors","date":"2023-05-06T02:40:38.921Z","updated":"2023-05-05T01:19:36.000Z","comments":true,"path":"code/dotnet/dotnet -- 4. set 跨域 Cors/","link":"","permalink":"https://blog.zaiyuan.cc/code/dotnet/dotnet%20--%204.%20set%20%E8%B7%A8%E5%9F%9F%20Cors/","excerpt":"","text":".netcore cors 配置跨域是后端职责所在 核心代码如下: 12345678910111213141516// 从 appsetting 获取跨域列表var hostList = configuration.GetSection(&quot;Cors&quot;).GetChildren().Select(w =&gt; w.Value).ToArray();services.AddCors(setupAction =&gt;&#123; // 配置跨域规则 setupAction.AddPolicy(&quot;cors&quot;, setupAction =&gt; &#123; //setupAction.AllowAnyOrigin(); setupAction.AllowAnyHeader(); setupAction.AllowAnyMethod(); setupAction.AllowCredentials().WithOrigins(hostList); &#125;);&#125;);// 使用跨域中间件app.UseCors(&quot;cors&quot;); 辅助代码 appsetting.json 123456789101112&#123; &quot;Logging&quot;: &#123; &quot;LogLevel&quot;: &#123; &quot;Default&quot;: &quot;Information&quot;, &quot;Microsoft.AspNetCore&quot;: &quot;Warning&quot; &#125; &#125;, &quot;Cors&quot;: [ &quot;http://localhost:5000&quot;, &quot;http://192.168.52.21:5000&quot; ]&#125; configuration, services, app 12345678910111213public class Program&#123; public static void Main(string[] args) &#123; var builder = WebApplication.CreateBuilder(args); var services = builder.Services; var configuration = builder.Configuration; var app = builder.Build(); app.Run(); &#125;&#125;","categories":[],"tags":[{"name":"dotnet","slug":"dotnet","permalink":"https://blog.zaiyuan.cc/tags/dotnet/"},{"name":".netcore","slug":"netcore","permalink":"https://blog.zaiyuan.cc/tags/netcore/"}]},{"title":"dotnet -- 3. linux install dotnet","slug":"code/dotnet/dotnet -- 3. linux install dotnet","date":"2023-05-06T02:40:38.918Z","updated":"2023-05-05T01:55:40.000Z","comments":true,"path":"code/dotnet/dotnet -- 3. linux install dotnet/","link":"","permalink":"https://blog.zaiyuan.cc/code/dotnet/dotnet%20--%203.%20linux%20install%20dotnet/","excerpt":"","text":"脚本安装 下载地址: 点击下载 1bash dotnet-install.sh 官网https://learn.microsoft.com/zh-cn/dotnet/core/install/linux","categories":[],"tags":[{"name":"dotnet","slug":"dotnet","permalink":"https://blog.zaiyuan.cc/tags/dotnet/"},{"name":"linux","slug":"linux","permalink":"https://blog.zaiyuan.cc/tags/linux/"}]},{"title":"dotnet -- 2. set nuget","slug":"code/dotnet/dotnet -- 2. set nuget","date":"2023-05-06T02:40:38.915Z","updated":"2023-05-05T01:39:07.000Z","comments":true,"path":"code/dotnet/dotnet -- 2. set nuget/","link":"","permalink":"https://blog.zaiyuan.cc/code/dotnet/dotnet%20--%202.%20set%20nuget/","excerpt":"","text":"dotnet nuget add 1dotnet nuget add source &#123;url&#125; -n &#123;name&#125; remove 1dotnet nuget remove source &#123;name&#125; see 1dotnet nuget list source","categories":[],"tags":[{"name":"dotnet","slug":"dotnet","permalink":"https://blog.zaiyuan.cc/tags/dotnet/"}]},{"title":"dotnet -- 1. publish","slug":"code/dotnet/dotnet -- 1. publish","date":"2023-05-06T02:40:38.913Z","updated":"2023-05-05T02:02:01.000Z","comments":true,"path":"code/dotnet/dotnet -- 1. publish/","link":"","permalink":"https://blog.zaiyuan.cc/code/dotnet/dotnet%20--%201.%20publish/","excerpt":"","text":"dotnet publish1dotnet publish -c Release -r linux-x64 --self-contained false -o ./bin/publish -c -c Release -c Debug","categories":[],"tags":[{"name":"dotnet","slug":"dotnet","permalink":"https://blog.zaiyuan.cc/tags/dotnet/"}]},{"title":"ubuntu install dotnet sdk","slug":"shell/linux/ubuntu install dotnet sdk","date":"2023-05-06T02:40:38.908Z","updated":"2023-05-04T23:05:23.000Z","comments":true,"path":"shell/linux/ubuntu install dotnet sdk/","link":"","permalink":"https://blog.zaiyuan.cc/shell/linux/ubuntu%20install%20dotnet%20sdk/","excerpt":"","text":"ubuntu install dotnet sdk bash1234sudo apt-get update; \\sudo apt-get install -y apt-transport-https &amp;&amp; \\sudo apt-get update &amp;&amp; \\sudo apt-get install -y dotnet-sdk-6.0","categories":[],"tags":[]},{"title":"linux -- 脚本常用语法","slug":"shell/linux/linux -- 脚本常用语法","date":"2023-05-06T02:40:38.906Z","updated":"2023-05-04T23:36:10.000Z","comments":true,"path":"shell/linux/linux -- 脚本常用语法/","link":"","permalink":"https://blog.zaiyuan.cc/shell/linux/linux%20--%20%E8%84%9A%E6%9C%AC%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/","excerpt":"","text":"shell scriptShebang12#! /bin/bash#! /bin/python 执行方式1234567# 在当前进程执行， 所赋值的变量会保留source test.sh. test.sh# 在子进程中执行， 脚本执行结束子进程退出， 所赋值的变量会被回收bash test.sh./test.sh 字符串内执行命令用 &#96;&#96; cat test.sh 123#! /bin/bashecho &quot;Current time: `date`&quot;; bash test.sh 1Current time: Wed 24 Aug 2022 05:58:00 PM CST print user info12345678 echo &quot;User name is: $USER&quot;; echo &quot;User uid is: $UID&quot;; echo &quot;User home is: $HOME&quot;;````## print who login```bash who 特殊符号 取出当前变量的值 12$&#123;vars&#125; $vars 在括号｀｀中执行命令， 且得到执行结果 12$(cmd)`cmd` 开启子shell执行命令 1(pwd; ls; type;) 三目运算 语法: [ cmd ] &amp;&amp; cmd || cmd 12count=1[ $((count++)) -lt 10 ] &amp;&amp; echo &quot;little than 10&quot; || echo &quot;great than 10&quot; 双小括号 (()) (()): 只会计算， 并没有结果 $(()): 计算后返回结果 12345678910111213141516171819i=1((i=i+1)) #运行结束后, i=2echo $((i=i+1)) # 执行结果 3; 且 i=3;i=$((i+1)) #运行结束后, i=4echo $((8&gt;9)) #: 0echo $((8&lt;9)) #: 1echo $((8*9)) #: 72echo $((8/9)) #: 0echo $((9/8)) #: 1echo $((8%6)) #: 2echo $((8**2)) #: 8的2次方 64 内置命令 &#x2F; 外置命令 内置命令: 系统启动就加载入内存, 效率高, 占资源 不会开启子进程执行 内置命令和 shell 是一体的, 是shell的一部分 查看所有内置命令: 1compgen -b 外置命令: 需要从硬盘加载, 读入内存 一定会开启子进程执行 可能存在如下目录: 1234/bin/usr/bin/sbin/usr/sbin 通过 type 来查看 内置 &#x2F; 外置 1type ps","categories":[],"tags":[]},{"title":"linux -- linux cmd","slug":"shell/linux/linux -- linux cmd","date":"2023-05-06T02:40:38.901Z","updated":"2023-05-04T23:15:53.000Z","comments":true,"path":"shell/linux/linux -- linux cmd/","link":"","permalink":"https://blog.zaiyuan.cc/shell/linux/linux%20--%20linux%20cmd/","excerpt":"","text":"查看系统信息1uname -a 查看硬盘情况df -h du -h /root 列举 /root 下所有目录 及子目录文件/文件夹大小 du -sh /root /root 大小 du -sh * 查看当前目录下, 所有大小 查看ip1ifconfig -all 重启1reboot 关机1shutdown -h now 查看当前所在位置1pwd 查看命令所在位置 which (要查询的命令)例如: which pod结果: &#x2F;usr&#x2F;local&#x2F;bin&#x2F;pod 进程pstree 查看进程树 ps123456ps -ef# -f 显示 UID, PID, PPID# -e 列出所有进程信息, 如同 -Aps -ef --forest #按tree的样子打印进程信息 创建进程列表 shell 的进程列表理念: 使用 小括号 () 1(cd ~; pwd; ls;) 检测是否在子 shell 环境中 该变量&#x3D;&#x3D;0: 在当前shell中运行, !&#x3D;0: 开启子shell运行 1$BASH_SUBSHELL","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://blog.zaiyuan.cc/tags/linux/"}]},{"title":"Joplin - github pages","slug":"other/tools/Joplin - github pages","date":"2023-05-06T02:40:38.872Z","updated":"2023-05-04T06:07:28.000Z","comments":true,"path":"other/tools/Joplin - github pages/","link":"","permalink":"https://blog.zaiyuan.cc/other/tools/Joplin%20-%20github%20pages/","excerpt":"","text":"Joplin 导出, hexo 发布到 github pages 支持图片 Joplin 导出 markdown 后有两个文件夹 在 Joplin 里写markdown文章, 直接拖本地图片到编辑区, joplin 会保存图片到_resources文件夹 对指定文件夹 _post 点右键导出 选择 “markdown+文章前言” _post _resources 将这两个文件夹直接 copy 到 hexo 的 source 目录下 调试 hexo 直接 hexo s 运行, 此时会发现有文章生成, 但是图片不显示 debug 后发现生成的文章url与图片路径不匹配 解决办法: 修改文章url12# hexo: / _config.ymlpermalink: :title/ 再次 hexo s, 发现还是没有图片 debug 发现 _resources 文件夹并没有自动copy 解决办法: 配置copy _resources 文件夹123# hexo: / _config.ymlinclude: - _resources/* 此时 hexo s, 即可看到图片 hexo g, 发布, 上传到 github.io 调试 github.io 打开 github pages, 发现还是没有图片 debug 后, 发现还是无法访问_resources 再次检查后, 发现 github.io &gt; setting &gt; pages &gt; build and deployment &gt; deploy from a branch 此选项使用的是 jekyll 来生成 github pages jekyll 默认会跳过 . _ # 等前缀的文件夹 参考 解决办法: 配置 jekyll 参考 在 github.io 根目录下创建 _config.yml 文件 123# github.io: _config.ymlinclude: - _resources 此时重新生成, 就会有图片了 The end","categories":[],"tags":[{"name":"tools","slug":"tools","permalink":"https://blog.zaiyuan.cc/tags/tools/"},{"name":"github","slug":"github","permalink":"https://blog.zaiyuan.cc/tags/github/"},{"name":"joplin","slug":"joplin","permalink":"https://blog.zaiyuan.cc/tags/joplin/"}]},{"title":"note - Joplin 笔记软件","slug":"other/tools/note - Joplin 笔记软件","date":"2023-05-06T02:40:38.867Z","updated":"2023-04-27T23:45:22.000Z","comments":true,"path":"other/tools/note - Joplin 笔记软件/","link":"","permalink":"https://blog.zaiyuan.cc/other/tools/note%20-%20Joplin%20%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6/","excerpt":"","text":"Joplin 笔记软件 主要功能&#x2F;特性 markdown 完美支持 markdown 导入导出 可以导出&#x2F;导入markdown 支持 tags, title, created, updated 等特性 的导入&#x2F;导出 可以导出 html 同步 需要下载客户端使用 不能再网页中使用 有如下多种同步模式 可以使用 docker 部署 Joplin Server 进行同步 WebDAV 同步 可以配合 AList 把网盘作为备份盘 可以配合 AList 把服务器目录作为备份盘 1234# ***: alist 服务器地址# /dav: 固定# /joplin : alist 挂载目录http://***/dav/joplin 地址 中文 官网 GitHub","categories":[],"tags":[{"name":"tools","slug":"tools","permalink":"https://blog.zaiyuan.cc/tags/tools/"},{"name":"joplin","slug":"joplin","permalink":"https://blog.zaiyuan.cc/tags/joplin/"}]},{"title":"dota 梦境伤害","slug":"other/dota/dota 梦境伤害","date":"2023-05-06T02:40:38.860Z","updated":"2023-05-03T22:05:33.000Z","comments":true,"path":"other/dota/dota 梦境伤害/","link":"","permalink":"https://blog.zaiyuan.cc/other/dota/dota%20%E6%A2%A6%E5%A2%83%E4%BC%A4%E5%AE%B3/","excerpt":"","text":"梦境伤害 date boss burt(e) remark 2022-12-16 14:11:38 魔像武者 33.7 2022-12-26 14:01:39 艾雪拉 32 2022-12-27 14:02:33 吸血鬼 37.1 2022-12-28 13:51:17 大地之斧 37.0 2023-01-01 21:58:30 魔像武者 37 2023-01-02 21:58:53 齐天大圣 39.4 2023-01-03 18:03:01 小娜迦 14.7 2023-01-04 18:03:05 生化狂魔 37.1 2023-01-05 09:10:08 深渊 30.1 2023-01-06 15:19:48 毒藤魔女 49.3 2023-01-09 09:32:34 肉山魔王 14.0 2023-01-10 09:33:10 大娜迦 30.2 2023-01-11 10:45:39 艾雪拉 46.3 2023-01-12 13:56:22 吸血鬼 46.4 2023-01-13 15:33:09 大地之斧 33.9 2023-01-14 15:32:05 恶魔天使 39.4 2023-01-15 15:32:27 无畏骑士 38.1 2023-01-16 15:33:52 圣灵守护 41.3 2023-01-17 15:16:29 魔像武者 45.7 2023-01-18 15:17:10 齐天大圣 38.2 2023-01-19 15:17:41 小娜迦 13.3 2023-01-20 15:22:52 2023-01-21 15:23:07 深渊魔王 31.6 2023-01-22 15:27:21 毒藤魔女 55.7 2023-01-23 15:27:51 地狱血魔 47.4 2023-01-24 15:28:41 肉山魔王 24.9 2023-01-25 15:29:04 毒狗 20.2 2023-01-26 15:30:00 美杜莎 45.3 2023-01-27 15:30:20 艾雪拉 43.7 2023-01-28 15:30:50 吸血鬼 48.0 巫医 2023-01-29 15:31:37 大地之斧 42.1 普通 2023-01-30 14:17:05 堕落天使 44.0 2023-01-31 14:17:49 无畏骑士 44.5 巫医, 繁星 2023-02-01 14:18:54 圣灵守护 49.2 巫医 2023-02-02 14:19:22 魔像武者 52.3 巫医 2023-02-03 14:19:56 齐天大圣 64.4 巫医 2023-02-04 21:51:46 小娜迦 24.09 巫医, 繁星 2023-02-05 21:53:01 生化狂魔 38.06 巫医 2023-02-06 21:53:52 深渊魔王 35.89 巫医 2023-02-07 09:14:05 毒藤魔女 73.8 巫医 2023-02-08 09:15:18 地狱血魔 49.7 巫医, 繁星 2023-02-09 09:16:02 肉山魔王 21.8 巫医, 繁星 2023-02-10 09:17:02 毒狗 22 2023-02-11 09:17:44 美杜莎 49.5 2023-02-12 09:18:22 艾雪拉 73.6 巫医 2023-02-28 09:17:20 艾雪拉 78.35 巫医 2023-03-01 09:20:27 吸血鬼 54.97 巫医 2023-03-02 10:00:43 大地之斧 70.37 巫医 2023-03-03 10:01:04 堕落天使 88.5 2023-03-04 10:01:27 无畏骑士 57.22 2023-03-05 09:59:59 圣灵守护 81.83 巫医 2023-03-06 09:59:26 魔像武者 77.24 巫医 2023-03-07 13:33:24 齐天大圣 58.77 2023-03-08 13:34:03 小娜迦 27.26 2023-03-09 13:35:35 生化狂魔 92.54 2023-03-10 18:00:22 深渊魔王 52.27 2023-03-11 18:00:36 毒藤魔女 97.93 2023-03-12 18:00:45 地狱血魔 65.45 2023-03-13 18:00:54 肉山魔王 35.58 2023-03-14 09:03:44 毒狗 27.48 2023-03-15 09:04:31 美杜莎 56.85 2023-03-16 09:06:53 艾雪拉 73.67 2023-03-17 09:04:06 吸血鬼 99.18 2023-03-18 18:02:10 大地之斧 70.56 2023-03-19 18:02:22 堕落天使 99.99 2023-03-20 18:02:31 无畏骑士 65.40 2023-04-23 15:10:21 魔像武者 99.99 2023-04-24 15:10:45 齐天大圣 93.64 2023-04-25 10:28:30 小娜迦 30.5 2023-04-26 09:27:39 生化狂魔 99.99 2023-04-27 09:24:16 深渊魔王 65.31 2023-04-28 22:58:00 毒藤魔女 91.33 2023-04-29 18:00:45 地狱血魔 85.87 2023-04-30 18:00:54 肉山魔王 29.90 2023-05-01 09:03:44 毒狗 23.54 2023-05-02 09:04:31 美杜莎 84.66 2023-05-03 09:06:53 艾雪拉 99.99 2023-05-04 14:04:34 吸血鬼 99.99 小娜迦 巫医，深海，炽翼，赏金，繁星 第一次巫医、炽翼不开大 第二次全开 第三次及以后星深海赏金一起开","categories":[],"tags":[{"name":"dota","slug":"dota","permalink":"https://blog.zaiyuan.cc/tags/dota/"}]},{"title":"川藏线","slug":"other/川藏线","date":"2023-05-06T02:40:38.857Z","updated":"2023-05-04T19:14:06.000Z","comments":true,"path":"other/川藏线/","link":"","permalink":"https://blog.zaiyuan.cc/other/%E5%B7%9D%E8%97%8F%E7%BA%BF/","excerpt":"","text":"成都→雅安(147公里)→泸定(168公里)→康定(49公里)→新都桥(75公里)→雅江(74公里)→理塘(143公里)→巴塘(165公里)→竹笆笼(36公里)→芒康(71公里)→左贡(158公里)→邦达(107公里)→八宿(94公里)→然乌(90公里)-波密(129公里)→通麦(89公里)→林芝(127公里)→八一(19公里)→工布江达(127公里)→墨竹工卡(206公里)-拉萨(68公里)最佳出行时间：暮春(5、6月)和早秋(9、10月)。其中7、8月份属于雨季，行走川藏线比较危险，但是这个时间段处于暑假期间，出行人数有增无减，为了安全起见，一定要做好安全措施。出发前的装备和注意事项:进藏让人最担忧的就是高反，所以进藏除了要保持良好的心态外，对于健康的身体并无特殊要求，有严重呼吸气管、心脏、心血管、精神方面疾病的人不宜进藏，因此，对于有严重的高血压、心脏病、（支）气管炎、糖尿病、感冒的患者限制进藏。建议您在进藏前对身体做一次心肺方面的检查，确认是否患有以上几种严重疾病。另外，在进藏前不要刻意的锻炼身体，如果您在平时一直坚持锻炼，在赴藏前半个月也应停下来，因为通过锻炼后的身体，耗氧量增大，增加了在西藏时心脏的负担，反而容易引起高原反应。就气温来说，除了藏北和阿里无人区，西藏的气温非常适合人类活动，特别是旅游。夏天，白天温度基本上都在二十五度以下，晚上在十度左右；冬季白天在十几度左右，晚上在零下几度，而我们的旅游活动都集中在白天，所以，夏天感觉不热，冬天也不会太冷。 进藏需带些什么药品？常规旅游准备一些感冒药品、胃肠类药品和一些去热止痛的药品就可以了，如：感冒片剂、感冒冲剂、泻痢停、复方阿斯匹林、扑尔敏、抗生素，若对高原反应没有信心，可以准备一些抗高原反应的药品：高原红景天（提前10天服用）、百服宁（控制高原反应引起的头痛）、高原安（抵西藏后服用）、西洋参含片。 对于完全背包客、徒步、探险之类的自助旅游，建议还要备一些一下药品： 常备药物：牛黄解毒片、黄莲素、牙周宁、息斯敏、乘晕宁； 抗高原反应药：诺迪康胶囊、西洋参（对缓解极度疲劳很有用）、速效救心丸、50%浓度的葡萄糖液（针剂型、非常适合当地不方便买到高原安红景天的驴友）； 外用药：云南白药花油、创可贴、清凉油、风油精、伤湿止痛膏、眼药水、药棉、紗布、绷带、白胶布； 进藏需带哪些食品？为了防止饮食不习惯或被堵在半路上，可以带上：巧克力、牛肉干、榨菜、饼干及其他个人爱好的食品和零食，最好是含热量高的食物。还可以带一些口香糖，因为嚼口香糖可以缓解耳鸣头痛，注意不要过密，会引起口干。 如果您是自助旅行，有可能会去到无人区，建议您再带上压缩饼干，有时还能起到救命的作用。 进藏必备日用品？进藏旅游必备用品：太阳镜、太阳帽、防晒霜、护肤霜、润唇膏、长袖上衣、毛衣； 对于自助旅游或去阿里、藏北、川藏线旅游，建议带：睡袋、羽绒服、登山鞋、拖鞋、牙刷、牙膏、毛巾、卷筒纸、纸内裤、消毒湿巾、手电筒、防水火柴、刀具、绳子。 进藏需要带什么样的衣服？鞋？由于西藏紫外线特别强，最好不要穿短袖上衣和短裤，必须备毛衣，春秋冬季建议带上羽绒服、保暖内衣，到珠峰、阿里地区、藏北地区一年四季都必须带羽绒服；鞋子最好是旅游鞋或登山鞋。如果您是背包自助游的话，冲锋衣、防雨衣裤、速干内衣、登山鞋，都是必不可少的。 车辆进藏前的准备：自驾车辆最好是血统纯正的越野吉普车，便于深度领略川藏沿线及周边美景，比如丰田4500、三菱帕杰罗等等，卡宴、宝马等豪华越野车也可，只是对于油品要求比较高，在某些地方反而受到限制。国产越野车陆风系列、江铃驭胜等则是比较物美价廉的选择。 车内需安装导航系统，GPS、指南针、最新电子地图、卫星电话，GPS定位系统可以准确定位车辆位置和指引道路，一路畅行，不用怕走错路。车载电池也不可少，可以为电子设备、通讯设备随时充电，保障安全。 车辆的维修装备则要包括修车专用工具，燃油添加剂、灭火器、水桶、备胎、照明灯泡、警示牌，以备行驶在无人的路上，车子坏了，自己还能简单的修理。 出发前进行车辆保养检修，根据自己出发的行程，准备好刹车片、机油格、检查好轮胎、玻璃等、轮胎最好多备上一个。 攻略地址:http://www.mafengwo.cn/i/5554232.html","categories":[],"tags":[]},{"title":"新冠 每日新增 趋势图","slug":"other/新冠 每日新增 趋势图","date":"2023-05-06T02:40:38.856Z","updated":"2023-05-04T19:10:05.000Z","comments":true,"path":"other/新冠 每日新增 趋势图/","link":"","permalink":"https://blog.zaiyuan.cc/other/%E6%96%B0%E5%86%A0%20%E6%AF%8F%E6%97%A5%E6%96%B0%E5%A2%9E%20%E8%B6%8B%E5%8A%BF%E5%9B%BE/","excerpt":"","text":"数据来自百度No.1 美国 俄罗斯 英国 印度 意大利 法国 湖北","categories":[],"tags":[]},{"title":"github pages 域名绑定","slug":"other/github pages 域名绑定","date":"2023-05-06T02:40:38.850Z","updated":"2023-05-04T19:04:43.000Z","comments":true,"path":"other/github pages 域名绑定/","link":"","permalink":"https://blog.zaiyuan.cc/other/github%20pages%20%E5%9F%9F%E5%90%8D%E7%BB%91%E5%AE%9A/","excerpt":"","text":"github pages 域名绑定 购买域名 例如: abc.cn 域名下配置: 类型: CNAME 主机记录: xxx 记录值: xxx.github.io github pages 中设置 xxx.abc.cn","categories":[],"tags":[{"name":"github","slug":"github","permalink":"https://blog.zaiyuan.cc/tags/github/"}]},{"title":"算法 : Rabin-Karp 字符串编码","slug":"code/算法/算法 _ Rabin-Karp 字符串编码","date":"2023-04-28T09:23:24.454Z","updated":"2023-04-28T00:49:12.000Z","comments":true,"path":"code/算法/算法 _ Rabin-Karp 字符串编码/","link":"","permalink":"https://blog.zaiyuan.cc/code/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%20_%20Rabin-Karp%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81/","excerpt":"","text":"先看一个题目 「快乐前缀」是在原字符串中既是 非空 前缀也是后缀（不包括原字符串自身）的字符串。给你一个字符串 s，请你返回它的 __最长快乐前缀__。如果不存在满足题意的前缀，则返回一个空字符串。 示例 1：输入：s &#x3D; “level”输出：”l”解释：不包括 s 自己，一共有 4 个前缀（”l”, “le”, “lev”, “leve”）和 4 个后缀（”l”, “el”, “vel”, “evel”）。最长的既是前缀也是后缀的字符串是 “l” 。 示例 2：输入：s &#x3D; “ababab”输出：”abab”解释：”abab” 是最长的既是前缀也是后缀的字符串。题目允许前后缀在原字符串中重叠。 提示：1 &lt;&#x3D; s.length &lt;&#x3D; 10^5s 只含有小写英文字母 看完这个题后 , 觉得挺简单的, 为啥给了难度:困难 呢 分析一下 : 从字符串长度-1开始取前缀和后缀,判断是否相等,然后不相等的话长度再-1,再次取值比较当前缀与后缀相同的时候完成 例如 s &#x3D; “ababab”;可以写个循环step 1: pre &#x3D; “ababa”; suf &#x3D; “babab”; 不相等, nextstep 2: pre &#x3D; “abab”; suf &#x3D; “abab” 相等 , 找到答案 , so easy 用代码实现: 1234567891011121314151617class Solution &#123; func longestPrefix(_ s: String) -&gt; String &#123; if s.count &lt;= 1 &#123; return &quot;&quot;; &#125; for i in 0...s.count-2 &#123; let pre = s.prefix(s.count-1-i); let suf = s.suffix(s.count-1-i); if pre == suf &#123; return String(pre); &#125; &#125; return &quot;&quot;; &#125;&#125; 多么的完美, 直接提交 , 结果不出意料的 超时! 分析一下,感觉逻辑完美, 为什么会超时呢 据我的分析 pre &#x3D;&#x3D; suf 这一句当字符串很长的时候,耗时严重,当判断两个字符串是否相等的时候, 会把__两个字符串每一位每一位的比较__,当发现有某一位不一样的时候, 就说明字符串不相同, 所以耗时很严重 ##怎么解决呢, 请出今天的主角: Rabin-Karp 字符串编码 背景知识:Rabin-Karp 字符串编码是一种将字符串映射成整数的编码方式，可以看成是一种哈希算法。具体地，假设字符串包含的字符种类不超过 ∣Σ∣（其中 Σ 表示字符集），那么我们选一个大于等于 ∣Σ∣ 的整数 base，就可以将字符串看成 base进制 的整数，将其转换成十进制数后，就得到了字符串对应的编码。 例如: 给定字符串 s &#x3D; “abca”，其包含的字符种类为 3（即 abc三种）。我们取 base &#x3D; 9，将字符串 s 看成九进制数 (0120)9 ，转换为十进制为 90，也就是说字符串 abca 的编码为 90。 这样做的好处是什么？我们可以发现一个结论： 两个字符串 s1 和 s2 相等，当且仅当它们的长度相等且编码值相等。 只考虑小写的情况下, 小写字母26个, 定义&gt;&#x3D;26进制的编码就可以了.例如 “abcdef” &#x3D; (012345)26 但是聪明的同学会发现个问题:当字符串长度变长的时候, 这个编码值会非常大, 这样可能就无法用一般语言中的整数类型（例如 int，long long 等）存储编码值了。对此，一般的解决方法是将编码值对一个数 mod 进行取模，使得其保持在整数类型的范围之内。 但这样就带来了一个问题，两个不相同但长度相等的字符串在取模前会有不同的编码值，在取模后的编码值就有可能相同了。换句话说，我们的编码方式不是单射，这种哈希算法会产生碰撞。然而我们并不需要过分担心这个问题：只要我们将模数设置得很大，并且多选择一些模数，Rabin-Karp 字符串编码产生哈希碰撞的概率就微乎其微。一般来说，对于算法题而言，我们只需要选择一个模数即可，并且它最好是一个__质数__，例如 10^9+7。如有需要，还可以选择第二个模数 10^9+9 。对于前文提到的 __base，一般也选择一个质数__，例如本题中 ∣Σ∣&#x3D;26（即所有小写英文字母），我们可以选择 base&#x3D;31 (&gt;&#x3D; 26的质数)。 算法对于这道题而言:设定: base &#x3D; 31; mod &#x3D; 1000000007; &#x2F;&#x2F; 10^9+7 我们从小到大枚举前缀的长度 i。然后计算 i 对应的前缀编码值和后缀编码值。如果这两个编码值相等，我们就可以判定该前缀和后缀相等。 对于前缀而言，每在字符串最后多出一个新的字符，就相当于原编码值乘以 base 再加上新的字符的编码值； 例如bcd,b &#x3D; (1) 31 &#x3D; b;bc &#x3D; (12)31 &#x3D; (1 * 31 + 2)10 &#x3D; b * 31 + cbcd &#x3D; (123)31 &#x3D; (1 * 31 * 31 + 2 * 31 + 3) &#x3D; (b * 31 * 31 + c * 31 + d) &#x3D; (b * 31 + c) * 31 + d &#x3D; bc*31+d 对于后缀而言，每在字符串最前多出一个新的字符，就相当于原编码值加上新的字符的编码值乘以 base 的 i-1 次幂。 例如bcd,d &#x3D; (3) 31 &#x3D; d;cd &#x3D; (23)31 &#x3D; (2 * 31 + 3)10 &#x3D; c * 31 + dbcd &#x3D; (123)31 &#x3D; (1 * 31 * 31 + 2 * 31 + 3) &#x3D; (b * 31 * 31 + c * 31 + d) &#x3D; b * 31 * 31 + cd 到此就到了最重要的写代码环节了: 12345678910111213141516171819202122232425262728293031323334class Solution &#123; func longestPrefix(_ s: String) -&gt; String &#123; let base = 31; // 大于取值范围的质数 , 代表 31 进制 let mod = 1000000007; let n = s.count; let s = s.cString(using: .utf8) ?? []; let a = 97; var preValue = 0; // 前缀值 var sufValue = 0; // 后缀值 var mul = 1; // mul = (base)的 n-1 次方 var happy = -1; for i in 0..&lt;n-1 &#123; preValue = (preValue * base + Int(s[i])-a)%mod; sufValue = (sufValue + (Int(s[n-i-1])-a) * mul)%mod; if preValue == sufValue &#123; happy = i; &#125; // 每计算一次 mul * base; mul = base ^ i mul = mul * base % mod; &#125; if (happy &lt; 0) &#123; return &quot;&quot;; &#125; else &#123; return String(String.init(cString: s).prefix(happy+1)); &#125; &#125;&#125; 同样是循环比较每个子串是否相等, 这样的效率会高很多…… The End这是我学习LeetCode上的知识的一个总结 , 并非原版照抄 , 原版十分生硬, 看了好久才看明白…赋原文链接: LeetCode原文","categories":[],"tags":[]},{"title":"KMP 算法小记","slug":"code/算法/KMP 算法小记","date":"2023-04-28T09:23:24.452Z","updated":"2023-04-28T00:40:48.000Z","comments":true,"path":"code/算法/KMP 算法小记/","link":"","permalink":"https://blog.zaiyuan.cc/code/%E7%AE%97%E6%B3%95/KMP%20%E7%AE%97%E6%B3%95%E5%B0%8F%E8%AE%B0/","excerpt":"","text":"KMP 算法 主要是用来从一个主串s中查找子串p的位置 要从 s 中找 p 首先想到的就是暴力搜索暴力搜索示例:s &#x3D; “abcdabce”p &#x3D; “bce” step 1: 12abcdabcebce a &#x3D;&#x3D; b ? 不相等, 则next setp 2: 12abcdabce bce b&#x3D;&#x3D;b ? c&#x3D;&#x3D;c ? d&#x3D;&#x3D;e? 显然 d!&#x3D;e , next step 3:12abcdabce bce c &#x3D;&#x3D; b ? 不相等 , next ……直至到最后找出结果 这么做的话会发现比较浪费, 在 setp 2中, p中的 b与c 都比较过了,能不能想办法不再比较 b 与c 了, 这个办法就是 kmp 下面给出 swift 版本代码 : 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution &#123; var next: [Int] = []; func kmpSearch(_ s: String ,_ p: String) -&gt; Int &#123; next = getNext(p); let sLen = s.count; let pLen = p.count; let s = s.cString(using: .utf8); let p = p.cString(using: .utf8); var i = 0; var j = 0; while (i &lt; sLen &amp;&amp; j &lt; pLen ) &#123; // 当 p 与 s 第一个字符都不匹配的时候 (j == -1) // 或当 p 与 s 当前字符匹配成功 (s?[i] == p?[j]) // 则进行下一个字符匹配 if j == -1 || s?[i] == p?[j] &#123; i += 1; j += 1; &#125; else &#123; // 如果 当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j] // next[j] 即为 j 所对应的 next 值 j = next[j]; &#125; &#125; if j == pLen &#123; return i - j; &#125; return -1; &#125; func getNext(_ p: String ) -&gt; [Int] &#123; let len = p.count; let p = p.cString(using: .utf8); var next = Array.init(repeating: 0, count: len); next[0] = -1; var k = -1; var j = 0; while j &lt; len - 1 &#123; //p[k]表示前缀，p[j]表示后缀 if (k == -1 || p?[j] == p?[k]) &#123; j += 1; k += 1; if p?[j] != p?[k] &#123; next[j] = k; &#125; else &#123; //因为不能出现p[j] = p[next[j ]]，所以当出现时需要继续递归，k = next[k] = next[next[k]] next[j] = next[k]; &#125; &#125; else &#123; k = next[k]; &#125; &#125; return next; &#125;&#125;let so = Solution();let result = so.kmpSearch(&quot;abaabababaaababaabaa&quot;,&quot;aabaa&quot;);print(result); 原文地址 : 从头到尾彻底理解KMP通读了两遍 , 大概理解了 , 脑袋记不住只能存下来了","categories":[],"tags":[]},{"title":"用chrome浏览器 下载 fir.im 的 ipa - 简书","slug":"code/iOS/用chrome浏览器 下载 fir.im 的 ipa - 简书","date":"2023-04-28T09:23:24.445Z","updated":"2023-04-28T00:37:26.000Z","comments":true,"path":"code/iOS/用chrome浏览器 下载 fir.im 的 ipa - 简书/","link":"","permalink":"https://blog.zaiyuan.cc/code/iOS/%E7%94%A8chrome%E6%B5%8F%E8%A7%88%E5%99%A8%20%E4%B8%8B%E8%BD%BD%20fir.im%20%E7%9A%84%20ipa%20-%20%E7%AE%80%E4%B9%A6/","excerpt":"","text":"在浏览器上输入下载地址 进入调试模式 用调试模式里的手机模式重新加载, 选iPhone机型, 如图所示 点击下载安装, console 会弹出一条报错信息 点击报错信息, 浏览器会弹出新页面打开 复制地址的后半段 https 以后的, 如图 使用地址解析解析出 install 下载地址, 打开下载地址 下载出 install 文件后, 用 文本文档打开, 从中找到真正的下载地址 下载ipa the end!","categories":[],"tags":[]},{"title":"vue5 -- 配置跨域","slug":"code/vue/vue5 -- 配置跨域","date":"2023-04-28T09:23:24.442Z","updated":"2023-02-10T02:02:37.000Z","comments":true,"path":"code/vue/vue5 -- 配置跨域/","link":"","permalink":"https://blog.zaiyuan.cc/code/vue/vue5%20--%20%E9%85%8D%E7%BD%AE%E8%B7%A8%E5%9F%9F/","excerpt":"","text":"1. 概念 同源策略： 是一种约定，web 与 获取的数据同源, 才能被当前web接受&#x2F;运行 它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。 为什么会有不同源: 在前后端分离的模式下，web 服务器 和 资源服务器会分开部署 前后端的域名是不一致的，此时就会发生跨域访问问题 跨域是什么： 浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域 即使域名相同, 端口不同 也是跨域的。 2. 跨域处理 正规情况下, 需要后端配置跨域规则, 在后端把前端的地址端口配置进去即可 请求示例 1234567891011Host: 192.168.52.21:8001Connection: keep-aliveAccept: */*Access-Control-Request-Method: GETAccess-Control-Request-Headers: x-requestidOrigin: http://192.168.52.21:8080User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36Sec-Fetch-Mode: corsReferer: http://192.168.52.21:8080/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9 返回示例 12345678HTTP/1.1 204 No ContentDate: Fri, 10 Feb 2023 08:25:38 GMTServer: KestrelAccess-Control-Allow-Credentials: trueAccess-Control-Allow-Headers: x-requestidAccess-Control-Allow-Methods: GETAccess-Control-Allow-Origin: http://192.168.52.21:8080Vary: Origin 3. 伪跨域 但是作为vue前端开发者, 可能主导不了要访问的后端, 开发的时候还必须跨域访问, 然后就有了伪跨域 vue 伪跨域原理 123451. vue 可以配置一个代理, 这个代理是跟前端地址同源的2. 在启动调试的时候, 会同时启动这个代理服务3. 然后请求后台的时候, 把地址配置成这个代理服务, 请求这个代理服务; 4. 在代理服务中配置真正的后台地址, 代理服务再请求到真正的后台; 5. 后台返回数据后, 代理服务 返回到当前页面; vue 伪跨域实现 配置代理服务 123456789101112131415// vue.config.jsconst &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;)module.exports = defineConfig(&#123; devServer: &#123; proxy: &#123; // 配置跨域, 开启一个代理服务 &#x27;/api&#x27;: &#123; // 代理服务的地址: /api target:&#x27;http://192.168.52.21:8001&#x27;, // 真正的后台地址 changOrigin: true, // 同意跨域 pathRewrite: &#123; // 重写url &#x27;/api&#x27;:&#x27;&#x27; &#125; &#125; &#125; &#125;&#125;) 配置url 1234const request = axios.create(&#123; baseURL: &#x27;/api&#x27;, //指向代理地址 timeout: 5000&#125;); 4. 重中之重 跨域是后端要配置的 前端只能是伪跨域 发布的时候 baseURL 要切换为真正的后台地址","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://blog.zaiyuan.cc/tags/vue/"},{"name":"cors","slug":"cors","permalink":"https://blog.zaiyuan.cc/tags/cors/"}]},{"title":"vue4 -- add axios","slug":"code/vue/vue4 -- add axios","date":"2023-04-28T09:23:24.440Z","updated":"2023-02-10T00:12:20.000Z","comments":true,"path":"code/vue/vue4 -- add axios/","link":"","permalink":"https://blog.zaiyuan.cc/code/vue/vue4%20--%20add%20axios/","excerpt":"","text":"1. axios axios 是用来网络请求的 2. 安装1npm install --save axios 3. 使用axios &#x2F; 封装 request.ts1234567891011121314151617181920212223242526272829303132333435363738// request.ts// 导入import axios from &quot;axios&quot;;// import * as tools from &#x27;./tools&#x27;;// 创建实例const request = axios.create(&#123; // baseURL: &#x27;/api&#x27;, baseURL: &#x27;https://localhost:6001&#x27;, timeout: 5000&#125;);// 请求拦截器request.interceptors.request.use((config) =&gt; &#123; config.headers[&quot;x-requestid&quot;] = tools.Random(99999, 9999999); return config;&#125;, (error) =&gt; &#123; return Promise.reject(error);&#125;);// 返回拦截器request.interceptors.response.use((response) =&gt; &#123; if (response.status == 200) &#123; // todo &#125; return response;&#125;, (error) =&gt; &#123; return Promise.reject(error);&#125;);// 导出接口方法export function LogDotaGetDeviceList() &#123; return request(&#123; url: &quot;/LogDota/GetDeviceList&quot;, method: &quot;GET&quot; &#125;)&#125; tools.ts (非必要)12345// tools.tsexport function Random(min: number, max: number ) &#123; return Math.floor(Math.random() * (max - min)) + min;&#125; 4.使用 request.ts123456789101112131415161718&lt;script lang=&quot;ts&quot;&gt;import &#123; defineComponent &#125; from &#x27;vue&#x27;;import * as request from &quot;@/assets/common/request&quot;;export default defineComponent(&#123; created() &#123; request.LogDotaGetDeviceList() .then(res =&gt; &#123; console.log(res); &#125;) .catch(err =&gt; &#123; console.error(err); &#125;) &#125;&#125;)&lt;/script&gt;","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://blog.zaiyuan.cc/tags/vue/"}]},{"title":"vue3 -- add add sass","slug":"code/vue/vue3 -- add add sass","date":"2023-04-28T09:23:24.438Z","updated":"2023-01-31T18:13:01.000Z","comments":true,"path":"code/vue/vue3 -- add add sass/","link":"","permalink":"https://blog.zaiyuan.cc/code/vue/vue3%20--%20add%20add%20sass/","excerpt":"","text":"1. installnpm 安装 1npm i node-sass sass-loader -D 2. 此处安装可能出问题, 用下面方法可能能解决 管理员身份运行 powershell1npm install --global --producttion windows-build-tools 3. use1234567891011121314151617181920&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;hello&lt;/h1&gt; &lt;el-button&gt;hello&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot;&gt;primary&lt;/el-button&gt; &lt;el-button type=&quot;info&quot;&gt; info &lt;/el-button&gt; &lt;el-button type=&quot;danger&quot;&gt;danger&lt;/el-button&gt; &lt;el-button type=&quot;success&quot;&gt;success&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;style lang=&quot;scss&quot;&gt;.hello&#123; background: yellow; .el-button&#123; color: red; &#125;&#125;&lt;/style&gt; 4. reset.css 在 src&gt;assets&gt;css 下创建reset.css文件 粘贴下面内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* http://meyerweb.com/eric/tools/css/reset/ v2.0 | 20110126 License: none (public domain)*/html, body, div, span, applet, object, iframe,h1, h2, h3, h4, h5, h6, p, blockquote, pre,a, abbr, acronym, address, big, cite, code,del, dfn, em, img, ins, kbd, q, s, samp,small, strike, strong, sub, sup, tt, var,b, u, i, center,dl, dt, dd, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot, thead, tr, th, td,article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary,time, mark, audio, video &#123; margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline;&#125;/* HTML5 display-role reset for older browsers */article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section &#123; display: block;&#125;body &#123; line-height: 1;&#125;ol, ul &#123; list-style: none;&#125;blockquote, q &#123; quotes: none;&#125;blockquote:before, blockquote:after,q:before, q:after &#123; content: &#x27;&#x27;; content: none;&#125;table &#123; border-collapse: collapse; border-spacing: 0;&#125; 在 App.vue 文件里 &lt; style&gt; 第一行加 @import12345678910&lt;style lang=&quot;scss&quot;&gt;@import url(&#x27;./assets/css/reset.css&#x27;);#app &#123; font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; /* margin-top: 60px; */&#125;","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://blog.zaiyuan.cc/tags/vue/"},{"name":"sass","slug":"sass","permalink":"https://blog.zaiyuan.cc/tags/sass/"}]},{"title":"vue2 -- add element ui / plus","slug":"code/vue/vue2 -- add element ui _ plus","date":"2023-04-28T09:23:24.436Z","updated":"2023-01-31T01:27:23.000Z","comments":true,"path":"code/vue/vue2 -- add element ui _ plus/","link":"","permalink":"https://blog.zaiyuan.cc/code/vue/vue2%20--%20add%20element%20ui%20_%20plus/","excerpt":"","text":"1. installnpm 安装 1npm i element-ui -S 2. 完整引入1234567891011121314import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import ElementUI from &#x27;element-ui&#x27;import &#x27;element-ui/lib/theme-chalk/index.css&#x27;Vue.use(ElementUI)Vue.config.productionTip = falsenew Vue(&#123; render: h =&gt; h(App),&#125;).$mount(&#x27;#app&#x27;) 3. use1234567891011&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;hello&lt;/h1&gt; &lt;el-button&gt;hello&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot;&gt;primary&lt;/el-button&gt; &lt;el-button type=&quot;info&quot;&gt; info &lt;/el-button&gt; &lt;el-button type=&quot;danger&quot;&gt;danger&lt;/el-button&gt; &lt;el-button type=&quot;success&quot;&gt;success&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt; 4. vue3 用的是 element plus 官网 https://element-plus.gitee.io/zh-CN/ 安装 1npm install element-plus --save 使用 main.ts 123456789import &#123; createApp &#125; from &#x27;vue&#x27;import ElementPlus from &#x27;element-plus&#x27;import &#x27;element-plus/dist/index.css&#x27;import App from &#x27;./App.vue&#x27;const app = createApp(App)app.use(ElementPlus)app.mount(&#x27;#app&#x27;) 使用 icon, 需要安装与引用地址: https://element-plus.gitee.io/zh-CN/component/icon.html","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://blog.zaiyuan.cc/tags/vue/"},{"name":"element_ui","slug":"element-ui","permalink":"https://blog.zaiyuan.cc/tags/element-ui/"}]},{"title":"vue1 -- vue cli create project","slug":"code/vue/vue1 -- vue cli create project","date":"2023-04-28T09:23:24.434Z","updated":"2023-01-30T05:18:55.000Z","comments":true,"path":"code/vue/vue1 -- vue cli create project/","link":"","permalink":"https://blog.zaiyuan.cc/code/vue/vue1%20--%20vue%20cli%20create%20project/","excerpt":"","text":"1. install123456789101112# 初始化项目依赖文件npm init -y # 安装脚手架cnpm i -D @vue/cli# 查看vuecli版本npx vue -V# 创建项目 貌似只能小写npx vue create project-one 安装 cnpm npm install -g cnpm –registry&#x3D;https://registry.npm.taobao.org 2. config vue.config.js12345678const &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;)module.exports = defineConfig(&#123; transpileDependencies: true, devServer: &#123; open: true, host: &quot;localhost&quot; &#125;&#125;)","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://blog.zaiyuan.cc/tags/vue/"},{"name":"vue_cli","slug":"vue-cli","permalink":"https://blog.zaiyuan.cc/tags/vue-cli/"}]},{"title":"sql -- cursor","slug":"code/sql/sql -- cursor","date":"2023-04-28T09:23:24.429Z","updated":"2023-02-07T22:59:06.000Z","comments":true,"path":"code/sql/sql -- cursor/","link":"","permalink":"https://blog.zaiyuan.cc/code/sql/sql%20--%20cursor/","excerpt":"","text":"open_cursor 查看所有游标 1SELECT * FROM v$open_cursor ORDER BY LAST_SQL_ACTIVE_TIME DESC 查看游标 sql_text 执行次数 123SELECT SQL_TEXT, COUNT(SQL_TEXT) times FROM v$open_cursor GROUP BY SQL_TEXTORDER BY times DESC FIND WHICH SESSION IN USING MORE CURSORS. 1234SELECT sid,user_name, COUNT(*) &quot;Cursors per session&quot;FROM v$open_cursor where user_name not like &#x27;SYS&#x27;GROUP BY sid,user_nameORDER BY &quot;Cursors per session&quot; DESC; Find which SQL is using more cursors 12345select sid, sql_id ,sql_text, count(*) as &quot;OPEN CURSORS&quot;, USER_NAME from v$open_cursor--where sid in (&#x27;&amp;SID&#x27;) GROUP BY SID,SQL_TEXT,USER_NAME,sql_idORDER BY &quot;OPEN CURSORS&quot; DESC; 游标最大数 123456select p.value as max_open_curfrom v$sesstat a, v$statname b, v$parameter pwhere a.statistic# = b.statistic#and b.name = &#x27;opened cursors current&#x27;and p.name= &#x27;open_cursors&#x27;group by p.value;","categories":[],"tags":[{"name":"sql","slug":"sql","permalink":"https://blog.zaiyuan.cc/tags/sql/"},{"name":"cursor","slug":"cursor","permalink":"https://blog.zaiyuan.cc/tags/cursor/"}]},{"title":"linux -- ubuntu config root","slug":"shell/linux/linux -- ubuntu config root","date":"2023-04-28T09:23:24.418Z","updated":"2022-12-26T19:46:48.000Z","comments":true,"path":"shell/linux/linux -- ubuntu config root/","link":"","permalink":"https://blog.zaiyuan.cc/shell/linux/linux%20--%20ubuntu%20config%20root/","excerpt":"","text":"1. 修改 sshd_config123456cd /etc/sshvim sshd_config# 找到 Authentication 下的 PermitRootLogin prohibit-password#修改为:PermitRootLogin yes 2. 重启 ssh1/etc/init.d/ssh restart 3. 重置 root 用户的密码 Ubuntu的默认root密码是随机的，即每次开机都有一个新的root密码 切换到普通用户 sudo passwd 根据提示输入当前用户的密码, 然后重置 root 的new密码 看到 password updated successfully, 就是重置好了","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://blog.zaiyuan.cc/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://blog.zaiyuan.cc/tags/ubuntu/"}]},{"title":"Hello World","slug":"shell/hexo/Hello World","date":"2023-04-28T09:23:24.415Z","updated":"2022-09-19T06:34:04.000Z","comments":true,"path":"shell/hexo/Hello World/","link":"","permalink":"https://blog.zaiyuan.cc/shell/hexo/Hello%20World/","excerpt":"","text":"Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://blog.zaiyuan.cc/tags/hexo/"}]},{"title":"Create Hexo","slug":"shell/hexo/Create Hexo","date":"2023-04-28T09:23:24.413Z","updated":"2022-09-19T06:34:05.000Z","comments":true,"path":"shell/hexo/Create Hexo/","link":"","permalink":"https://blog.zaiyuan.cc/shell/hexo/Create%20Hexo/","excerpt":"","text":"安装 安装前提: nodejs 安装 nodejs 直接下载安装: Nodejs 安装 hexo1npm install -g hexo-cli 初始化项目 找个文件夹1hexo init 使用 vexo theme theme 地址: Vexo Download&#x2F;Checkout this theme into your project 12345cd your-hexo-foldergit clone https://github.com/yanm1ng/hexo-theme-vexo.git themes/vexocp -R themes/vexo/_source/* source/ Update project _config.yml theme config, look like this 1themes: vexo Here theme’s name must same as the theme folder name. Modify theme themes/vexo/_config.yml with your own info. 创建新文章1hexo new &quot;title&quot; 发布 测试, 查看效果 hexo server 生成到 public 文件夹 hexo g copy public 里的内容到 github.io 项目, 并提交 最后, 提交本项目更改","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://blog.zaiyuan.cc/tags/hexo/"}]},{"title":"linux 下 git 免密","slug":"shell/git/linux 下 git 免密","date":"2023-04-28T09:23:24.411Z","updated":"2022-09-20T19:14:00.000Z","comments":true,"path":"shell/git/linux 下 git 免密/","link":"","permalink":"https://blog.zaiyuan.cc/shell/git/linux%20%E4%B8%8B%20git%20%E5%85%8D%E5%AF%86/","excerpt":"","text":"方法一 cd到~&#x2F;目录下，创建一个文件：touch .git-credentialsvim .git-credentials 然后输入https:&#x2F;&#x2F;{username}:{password}@git.gitxx.com，比如http://fengjiaheng:password@git.gitxx.com 然后执行：git config –global credential.helper store 然后使用git config –list或者查看一下~&#x2F;.gitconfig文件，会发现多了一行[credential] helper &#x3D; store 这时候再用 git 拉取仓库就不需要输入用户名和密码了。注意：第4步必须要做，否则做完4、5步之后也不能免密码拉取成功，需要再次执行第4步骤。 方法二 粗暴使用型Git Clone命令直接使用用户名密码Clone git clone http://userName:password@链接修改为 git clone https://username:password@链接 示例：git clone git@http://112.12.122.22:t-mapi/hotel-tapi.git修改为git clone ‘http://username:password@112.12.122.22:t-mapi/hotel-tapi.git’ 注意事项（2）如果账号username或者password中有@符号,需要 将@替换为%40（3）如果报错git clone event not found，需要将 git clone 后地址加上引号 ‘’","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://blog.zaiyuan.cc/tags/git/"},{"name":"linux","slug":"linux","permalink":"https://blog.zaiyuan.cc/tags/linux/"}]},{"title":"git 命令小记","slug":"shell/git/git 命令小记","date":"2023-04-28T09:23:24.408Z","updated":"2022-12-02T02:02:50.000Z","comments":true,"path":"shell/git/git 命令小记/","link":"","permalink":"https://blog.zaiyuan.cc/shell/git/git%20%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0/","excerpt":"","text":"配置 git config –global user.name “xxxxxx” 配置全局用户名 git config –global user.email “&#x78;&#120;&#x78;&#x78;&#x78;&#120;&#x40;&#x78;&#120;&#120;&#x2e;&#x63;&#111;&#x6d;“ 配置全局用户邮箱 git config –global core.editor vim 配置git 提交信息的编辑器 以上命令省去 –global 可以对单独的项目进行配置 在git的全局配置（~&#x2F;.gitconfig）中可以对 一些命令起别名 在每个git管理的项目中可以假如 .gitignore 文件用来设置 可以被忽略的文件格式 基础命令 git status 查看文件状态 git add 把文件添加到git , 需要添加多个文件时，可以使用 add .或者 add * 来批量添加所有文件 git commit -m “备注信息” git commit -a -m &quot;备注信息&quot; 可以把 已经至少add过一次的所有文件（假如是新文件，就不会被提交）的修改提交 提交文件，并且加上提交时的备注信息，如果不加-m 会进入编辑器界面编辑备注信息 git log 查看历史提交记录 git tag -m”备注” &lt;commit值&gt; 给固定的记录打上标记 git cat-file -p &lt;commit值&gt; 查看指定commit中所包含的内容 tree 是指本次提交中的文件结构 parent 是本次commit的父节点 blob 是具体的文件的对象 撤销修改 git checkout 从历史区中捡出 file 把当前工作区中修改的内容覆盖掉 这样的操作比较危险，误操作时容易把工作区的改动全部删除 git stash 把当前工作区的中修改撤销 ，撤销的修改会以 栈 的形式存放 ，如果需要把撤销再复原的话，可以使用 git stash pop 把撤销拿回来; 如果需要彻底清空 stash里的内容可以 使用 git stash clear来清除垃圾区 git rm 可以把文件从历史区中删除，所以要想从git管理中删除某一个文件，必须使用 git rm，而不是直接使用rm git reset HEAD 可以把已经add到暂存区的修改再撤销回工作区vi 对比文件差异 git diff 分支操作 git branch 列出当前所有分支 1.1 git branch –all &#x2F;&#x2F; 所有的分支 git branch &lt;分支名&gt; 基于当前分支的最新提交拉取一次分支 git checkout &lt;分支名&gt; 切换到指定的分支上去 - 切换远程分支到本地 git checkout -b cad_team_a remotes/origin/cad_team_a git branch -d &lt;分支名&gt; 删除指定的分支 ，如果确定需要删除可以使用 -D 强制删除 git checkout -b &lt;分支名&gt; 会创建并且切换到该分支 git reset –hard &lt;commit值&gt; 可以回退本分支上的某一次 具体的提交 git merge &lt;分支名&gt; merge是把指定分支合并到当前的分支 git merge --no-merged 可以查看当前还有哪些分支与当前分支没有合并的 git merge --merge 可以查看已经与当前分支合并过的分支 git cherry-pick &lt;commit值&gt; 从别的分支上捡出一个commit与当前分支合并 git rebase 重衍（变基）命令 将某个分支的改动直接加入到某一指定分支上冲重新开展，效果是在最终的log里看不到有侧分支的痕迹 1 切换到需要 重衍的 分支 git checkout someBranch （需要重衍的分支） 2 执行重衍命令 git rebase baseBranch (重衍基于的分支) 3 切换到基于的分支合并重衍的分支 git checkout baseBranch &gt; git merge someBranch 远程操作 git clone 克隆远端仓库 基于ssh的远端地址 ssh://qingyun@192.168.1.233:/Users/qingyun/Desktop/code1512/Code/20160128/TestRemote 基于http/https的远端地址 http(https)://xxx.xxx.com/xxxx.git 加 -o 可以给远端仓库改名，默认是 origin git remote 列出远端仓库列表 git remote rename remoteName newName 给远端仓库改名 git remote show 列出远端仓库列表 git remote add &lt;仓库名&gt; &lt;远端地址&gt; 添加新的远端仓库 git remote rm &lt;仓库名&gt; 删除指定远端仓库 git fetch 拉取远端仓库内容 git fetch &lt;仓库名&gt; 拉取指定远端仓库的内容 fetch只是把远端仓库内容下载到本地，如果需要将内容与本地分支合并 需要 git merge &lt;仓库名&gt;/&lt;分支名&gt; git pull &lt;仓库名&gt; &lt;远端分支名&gt; 拉取远端分支并且跟本地分支合并 类似 fetch+merge 的组合 git push &lt;仓库名&gt; &lt;本地分支名&gt; 推送到服务器 git push &lt;仓库名&gt; :&lt;服务器分支名&gt; 删除服务器上的某一分支","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://blog.zaiyuan.cc/tags/git/"}]},{"title":"docker -- 7. AList 网盘挂载","slug":"shell/docker/docker -- 7. AList 网盘挂载","date":"2023-04-28T09:23:24.406Z","updated":"2023-04-27T22:56:30.000Z","comments":true,"path":"shell/docker/docker -- 7. AList 网盘挂载/","link":"","permalink":"https://blog.zaiyuan.cc/shell/docker/docker%20--%207.%20AList%20%E7%BD%91%E7%9B%98%E6%8C%82%E8%BD%BD/","excerpt":"","text":"AList 网盘挂载 地址 AList GitHub Alist文档 主要功能&#x2F;特点 挂载本地 挂载各种网盘 网页统一访问 支持 WebDAV 协议对外访问 Docker 中使用1234567891011121314version: &#x27;3.7&#x27;services: trilium: image: zadam/trilium container_name: trilium restart: always ports: - 8008:8080 volumes: # 把同文件夹下的 trilium-data 目录映射到容器内 - ./trilium/data:/home/node/trilium-data environment: # 环境变量表示容器内笔记数据的存储路径 - TRILIUM_DATA_DIR=/home/node/trilium-data Docker 下查看admin密码12docker exec -it alist bash./alist admin","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"https://blog.zaiyuan.cc/tags/docker/"}]},{"title":"docker -- 6. trilium 博客系统","slug":"shell/docker/docker -- 6. trilium 博客系统","date":"2023-04-28T09:23:24.405Z","updated":"2023-04-27T22:39:04.000Z","comments":true,"path":"shell/docker/docker -- 6. trilium 博客系统/","link":"","permalink":"https://blog.zaiyuan.cc/shell/docker/docker%20--%206.%20trilium%20%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"trilium 博客系统 地址 中文 github 地址 原版地址 wiki 地址 主要功能(使用几天的感受) 支持 markdown, 但感觉不太多 Trilium 使用了很棒的CKEditor 5作为它的编辑组件。但我感觉不太好用, 可能是不会 可以导出&#x2F;导入markdown, 不是完美兼容 可以导出html 有客户端, 可以在客户端直接编辑, 随后同步到服务器 部署私有服务器, 数据在自己手中 Docker 中使用1234567891011121314version: &#x27;3.7&#x27;services: trilium: image: zadam/trilium container_name: trilium restart: always ports: - 8008:8080 volumes: # 把同文件夹下的 trilium-data 目录映射到容器内 - ./trilium/data:/home/node/trilium-data environment: # 环境变量表示容器内笔记数据的存储路径 - TRILIUM_DATA_DIR=/home/node/trilium-data","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"https://blog.zaiyuan.cc/tags/docker/"}]},{"title":"docker -- 5. filebrowser 文件服务器","slug":"shell/docker/docker -- 5. filebrowser 文件服务器","date":"2023-04-28T09:23:24.402Z","updated":"2023-04-24T01:39:26.000Z","comments":true,"path":"shell/docker/docker -- 5. filebrowser 文件服务器/","link":"","permalink":"https://blog.zaiyuan.cc/shell/docker/docker%20--%205.%20filebrowser%20%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"filebrowser 文件服务器地址 github地址: GitHub feature: Feature 主要功能 上传文件 浏览文件 分享文件 下载文件 shell 默认账号密码: admin – admin","text":"filebrowser 文件服务器地址 github地址: GitHub feature: Feature 主要功能 上传文件 浏览文件 分享文件 下载文件 shell 默认账号密码: admin – admin Docker 中使用docker run12345678docker run \\ -v /path/to/root:/srv \\ -v /path/to/filebrowser.db:/database/filebrowser.db \\ -v /path/to/settings.json:/config/settings.json \\ -e PUID=$(id -u) \\ -e PGID=$(id -g) \\ -p 8080:80 \\ filebrowser/filebrowser:s6 docker-compose123456789101112version: &#x27;3.7&#x27;services: filebrowser: image: filebrowser/filebrowser:s6 container_name: filebrowser restart: always ports: - 8006:80 volumes: - ./filebrowser/srv:/srv - ./filebrowser/database:/database - ./filebrowser/config:/config","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"https://blog.zaiyuan.cc/tags/docker/"},{"name":"filebrowser","slug":"filebrowser","permalink":"https://blog.zaiyuan.cc/tags/filebrowser/"}]},{"title":"docker -- 4. nginx","slug":"shell/docker/docker -- 4. nginx","date":"2023-04-28T09:23:24.400Z","updated":"2023-04-24T00:53:32.000Z","comments":true,"path":"shell/docker/docker -- 4. nginx/","link":"","permalink":"https://blog.zaiyuan.cc/shell/docker/docker%20--%204.%20nginx/","excerpt":"nginxgithub地址主要功能主要特性","text":"nginxgithub地址主要功能主要特性 Docker 中使用docker rundocker-compose1234567891011121314version: &#x27;3.7&#x27;services: nginx: image: nginx container_name: nginx restart: always ports: - 8080:80 volumes: - ./nginx/nginx:/etc/nginx - ./nginx/html:/usr/share/nginx/html - ./nginx/logs:/var/log/nginx environment: TZ: Asia/Shanghai","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"https://blog.zaiyuan.cc/tags/docker/"},{"name":"nginx","slug":"nginx","permalink":"https://blog.zaiyuan.cc/tags/nginx/"}]},{"title":"docker -- 3. ddns-go","slug":"shell/docker/docker -- 3. ddns-go","date":"2023-04-28T09:23:24.399Z","updated":"2023-04-23T23:31:04.000Z","comments":true,"path":"shell/docker/docker -- 3. ddns-go/","link":"","permalink":"https://blog.zaiyuan.cc/shell/docker/docker%20--%203.%20ddns-go/","excerpt":"ddns-gogithub地址 地址: GitHub 主要功能 自动获得你的公网 IPv4 或 IPv6 地址，并解析到对应的域名服务。 主要特性 支持Mac、Windows、Linux系统，支持ARM、x86架构 支持 Docker 中部署; 重要:docker 部署的时候需要使用host模式host模式只能在linux中使用所以只能在 linux 中 Docker 部署 支持的域名服务商 Alidns(阿里云) 支持多个域名同时解析 网页中配置，简单又方便，默认勾选禁止从公网访问 支持Webhook通知","text":"ddns-gogithub地址 地址: GitHub 主要功能 自动获得你的公网 IPv4 或 IPv6 地址，并解析到对应的域名服务。 主要特性 支持Mac、Windows、Linux系统，支持ARM、x86架构 支持 Docker 中部署; 重要:docker 部署的时候需要使用host模式host模式只能在linux中使用所以只能在 linux 中 Docker 部署 支持的域名服务商 Alidns(阿里云) 支持多个域名同时解析 网页中配置，简单又方便，默认勾选禁止从公网访问 支持Webhook通知 Docker 中使用docker run code12345docker run -d --name ddns-go \\--restart=always \\--net=host \\-v ./root:/root \\jeessy/ddns-go 在浏览器中打开http:&#x2F;&#x2F;主机IP:9876，修改你的配置，成功 docker-compose1234567891011version: &#x27;3.7&#x27;services: ddns: image: jeessy/ddns-go container_name: ddns-go restart: always network_mode: host volumes: - ./ddns-go/root:/root environment: TZ: Asia/Shanghai 系统中直接使用 看官网方法 其他功能 看官网","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"https://blog.zaiyuan.cc/tags/docker/"},{"name":"ddns","slug":"ddns","permalink":"https://blog.zaiyuan.cc/tags/ddns/"}]},{"title":"docker -- 2. mysql install","slug":"shell/docker/docker -- 2. mysql install","date":"2023-04-28T09:23:24.396Z","updated":"2023-04-27T22:58:35.000Z","comments":true,"path":"shell/docker/docker -- 2. mysql install/","link":"","permalink":"https://blog.zaiyuan.cc/shell/docker/docker%20--%202.%20mysql%20install/","excerpt":"","text":"mysql install创建文件 在要部署的地方, 创建 docker-compose.yaml 文件 创建 mysql 文件夹 编辑 docker-compose12345678910111213141516version: &#x27;3.7&#x27;services: mysql: image: mysql container_name: mysql restart: always ports: - 3306:3306 volumes: - ./mysql/data:/var/lib/mysql - ./mysql/my.cnf:/etc/mysql/my.cnf environment: MYSQL_ROOT_PASSWORD: 123456 TZ: Asia/Shanghai docker run1docker-compose up -d mysql other1docker run -d --name mysql-test -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql 进入mysql1docker exec -it mysql sh update mysql passwrod type123456789101112131415# 进入 mysqlmysql -u root -p# input passwordalter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;123456&#x27; password expire never;# 修改localhost 的验证方式alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified with mysql_native_password by &#x27;123456&#x27;;# 修改外部访问的验证方式, 外部访问直接改这个就行alter user &#x27;root&#x27;@&#x27;%&#x27; identified with mysql_native_password by &#x27;123456&#x27;;# 查看select user,host,plugin,authentication_string from user;","categories":[],"tags":[{"name":"mysql","slug":"mysql","permalink":"https://blog.zaiyuan.cc/tags/mysql/"},{"name":"sql","slug":"sql","permalink":"https://blog.zaiyuan.cc/tags/sql/"},{"name":"docker","slug":"docker","permalink":"https://blog.zaiyuan.cc/tags/docker/"}]},{"title":"docker -- 1. Dockerfile","slug":"shell/docker/docker -- 1. Dockerfile","date":"2023-04-28T09:23:24.395Z","updated":"2023-04-06T19:09:18.000Z","comments":true,"path":"shell/docker/docker -- 1. Dockerfile/","link":"","permalink":"https://blog.zaiyuan.cc/shell/docker/docker%20--%201.%20Dockerfile/","excerpt":"","text":"作用 Dockerfile 是用来构建镜像的 Dockerfile 里的每一行, build 的时候都会对应一个 image 调试 思路 dockerfile 里的每一行, build 的时候都会对应一个 image 一个image可以使用 docker create 命令创建一个 container 然后使用 docker export 命令将 container 导出为压缩包 解压即可看到image对应的文件 1234567docker build . -t image1docker create --name pack1 image1docker export pack1 &gt; pack1.tar COPY 命令使用 copy: 从本地路径 copy 到 image 内部 1234567# 设置 image 工作目录为 /srcWORKDIR /src# 第一个. : 本地 Dockerfile 所在路径# 第二个. : image内 /src# 类似于linux: copy ./* /srcCOPY . . copy 只能访问到 Dockerfile 所在目录, 所以: 只能是 COPY . . 不能 COPY .. . 路径说明 12345678910111213141516# Dockerfile 初始本地路径# /root/github/dir1/Dockerfile# /root/github/dir1/***.sln# /root/github/dir1/DM.Log.Service/***.scprojWORKDIR /srcCOPY . .# 此时, image内路径为:# /src/Dockerfile# /src/***.sln# /src/DM.Log.Service/***.# 即: /root/github/dir1/ == /src/WORKDIR &quot;/src/DM.Log.Service/.&quot; copy image 内部文件 1234567FROM build AS publishWORKDIR /app# --from=publish : 设置从 publish image进行copy# /app/publish : image 内部的路径 /app/publish# . : image内部WORKDIR所在路径, /appCOPY --from=publish /app/publish . 示例12345678910111213141516171819202122#See https://aka.ms/containerfastmode to understand how Visual Studio uses this Dockerfile to build your images for faster debugging.FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS baseWORKDIR /appEXPOSE 80EXPOSE 443FROM mcr.microsoft.com/dotnet/sdk:6.0 AS buildWORKDIR /srcCOPY . .WORKDIR &quot;/src/DM.Log.Service/.&quot;RUN dotnet restore &quot;./DM.Log.Service.csproj&quot;RUN dotnet build &quot;./DM.Log.Service.csproj&quot; -c Release -o /app/buildFROM build AS publishRUN dotnet publish &quot;./DM.Log.Service.csproj&quot; -c Release -o /app/publish /p:UseAppHost=falseFROM base AS finalWORKDIR /appCOPY --from=publish /app/publish .ENTRYPOINT [&quot;dotnet&quot;, &quot;DM.Log.Service.dll&quot;]","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"https://blog.zaiyuan.cc/tags/docker/"},{"name":"dockerfile","slug":"dockerfile","permalink":"https://blog.zaiyuan.cc/tags/dockerfile/"}]},{"title":"南传 UNT413a s905l3a","slug":"other/电视盒子/南传 UNT413a s905l3a","date":"2023-04-28T09:23:24.392Z","updated":"2023-04-27T22:17:25.000Z","comments":true,"path":"other/电视盒子/南传 UNT413a s905l3a/","link":"","permalink":"https://blog.zaiyuan.cc/other/%E7%94%B5%E8%A7%86%E7%9B%92%E5%AD%90/%E5%8D%97%E4%BC%A0%20UNT413a%20s905l3a/","excerpt":"","text":"dtc -I dtb -O dts -o meson-g12a-s905l3a-cm311.dts meson-g12a-s905l3a-cm311.dtb dtc -I dtb -O dts -o meson-g12a-s905l3a-m401a.dts meson-g12a-s905l3a-m401a.dtb m401adtc -I dtb -O dts -o meson-g12a-s905l3a-m401a.dts meson-g12a-s905l3a-m401a.dtbdtc -I dts -O dtb -o meson-g12a-s905l3a-m401a.dtb meson-g12a-s905l3a-m401a.dts 7.把你编译好的文件覆盖回原路径cp -f meson-g12a-s905l3a-cm311.dtb &#x2F;boot&#x2F;dtb&#x2F;amlogiccp -f meson-g12a-s905l3a-m401a.dtb &#x2F;boot&#x2F;dtb&#x2F;amlogic 8.保存，重启sync &amp;&amp; reboot","categories":[],"tags":[]},{"title":"windows tools","slug":"other/tools/windows tools","date":"2023-04-28T09:23:24.385Z","updated":"2023-02-10T02:02:37.000Z","comments":true,"path":"other/tools/windows tools/","link":"","permalink":"https://blog.zaiyuan.cc/other/tools/windows%20tools/","excerpt":"","text":"1. 下载工具 Motrix 一款全能的下载工具。支持下载 HTTP 、FTP 、BT 、磁力链接等资源。 官网: https://motrix.app/ qbittorrent 据说比 motrix 快 github地址: https://github.com/portapps/qbittorrent-portable 2. 截图软件 snipaste 确实好用 官网地址: https://zh.snipaste.com/ 3. utools 工具合集, 非常好用 快速启动 4. 剪贴板 copyQ 5. 硬件监控 trafficMonitor github: https://github.com/zhongyang219/TrafficMonitor 6. 快速预览 quicklook 空格键预览文件，开源 7. windows 使用时长 Tai 好看 好用 GitHub地址: https://github.com/Planshit/Tai 8. 字体美化 MacTypeTary 官方地址 https://www.mactype.net/","categories":[],"tags":[{"name":"tools","slug":"tools","permalink":"https://blog.zaiyuan.cc/tags/tools/"},{"name":"windows","slug":"windows","permalink":"https://blog.zaiyuan.cc/tags/windows/"}]},{"title":"Visual Studio Code tools","slug":"other/tools/Visual Studio Code tools","date":"2023-04-28T09:23:24.383Z","updated":"2023-02-21T23:55:52.000Z","comments":true,"path":"other/tools/Visual Studio Code tools/","link":"","permalink":"https://blog.zaiyuan.cc/other/tools/Visual%20Studio%20Code%20tools/","excerpt":"","text":"1. Git GitLens 查看行级别的Git提交记录 2. theme GitHub Theme 3. Markdown Markdown All in One markdown 编辑神器 Markdown Preview Enhanced markdown 预览神器 4. Js &#x2F; Ts ESLint 股票基金 韭菜盒子","categories":[],"tags":[{"name":"tools","slug":"tools","permalink":"https://blog.zaiyuan.cc/tags/tools/"},{"name":"vscode","slug":"vscode","permalink":"https://blog.zaiyuan.cc/tags/vscode/"}]}],"categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://blog.zaiyuan.cc/tags/%E7%AE%97%E6%B3%95/"},{"name":"ios","slug":"ios","permalink":"https://blog.zaiyuan.cc/tags/ios/"},{"name":"code","slug":"code","permalink":"https://blog.zaiyuan.cc/tags/code/"},{"name":"dotnet","slug":"dotnet","permalink":"https://blog.zaiyuan.cc/tags/dotnet/"},{"name":".netcore","slug":"netcore","permalink":"https://blog.zaiyuan.cc/tags/netcore/"},{"name":"linux","slug":"linux","permalink":"https://blog.zaiyuan.cc/tags/linux/"},{"name":"tools","slug":"tools","permalink":"https://blog.zaiyuan.cc/tags/tools/"},{"name":"github","slug":"github","permalink":"https://blog.zaiyuan.cc/tags/github/"},{"name":"joplin","slug":"joplin","permalink":"https://blog.zaiyuan.cc/tags/joplin/"},{"name":"dota","slug":"dota","permalink":"https://blog.zaiyuan.cc/tags/dota/"},{"name":"vue","slug":"vue","permalink":"https://blog.zaiyuan.cc/tags/vue/"},{"name":"cors","slug":"cors","permalink":"https://blog.zaiyuan.cc/tags/cors/"},{"name":"sass","slug":"sass","permalink":"https://blog.zaiyuan.cc/tags/sass/"},{"name":"element_ui","slug":"element-ui","permalink":"https://blog.zaiyuan.cc/tags/element-ui/"},{"name":"vue_cli","slug":"vue-cli","permalink":"https://blog.zaiyuan.cc/tags/vue-cli/"},{"name":"sql","slug":"sql","permalink":"https://blog.zaiyuan.cc/tags/sql/"},{"name":"cursor","slug":"cursor","permalink":"https://blog.zaiyuan.cc/tags/cursor/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://blog.zaiyuan.cc/tags/ubuntu/"},{"name":"hexo","slug":"hexo","permalink":"https://blog.zaiyuan.cc/tags/hexo/"},{"name":"git","slug":"git","permalink":"https://blog.zaiyuan.cc/tags/git/"},{"name":"docker","slug":"docker","permalink":"https://blog.zaiyuan.cc/tags/docker/"},{"name":"filebrowser","slug":"filebrowser","permalink":"https://blog.zaiyuan.cc/tags/filebrowser/"},{"name":"nginx","slug":"nginx","permalink":"https://blog.zaiyuan.cc/tags/nginx/"},{"name":"ddns","slug":"ddns","permalink":"https://blog.zaiyuan.cc/tags/ddns/"},{"name":"mysql","slug":"mysql","permalink":"https://blog.zaiyuan.cc/tags/mysql/"},{"name":"dockerfile","slug":"dockerfile","permalink":"https://blog.zaiyuan.cc/tags/dockerfile/"},{"name":"windows","slug":"windows","permalink":"https://blog.zaiyuan.cc/tags/windows/"},{"name":"vscode","slug":"vscode","permalink":"https://blog.zaiyuan.cc/tags/vscode/"}]}