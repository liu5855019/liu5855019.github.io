{"meta":{"title":"daimu's blog","subtitle":"","description":"daimu's blog","author":"daimu","url":"https://blog.zaiyuan.cc","root":"/"},"pages":[{"title":"关于","date":"2023-04-25T14:26:25.274Z","updated":"2023-04-25T14:26:25.274Z","comments":true,"path":"about/index.html","permalink":"https://blog.zaiyuan.cc/about/index.html","excerpt":"这是摘要 dd","text":"这是摘要 dd 这是正文"},{"title":"Project","date":"2023-02-18T12:45:56.305Z","updated":"2023-02-18T12:45:56.305Z","comments":true,"path":"project/index.html","permalink":"https://blog.zaiyuan.cc/project/index.html","excerpt":"","text":""},{"title":"Series","date":"2023-02-18T12:45:56.305Z","updated":"2023-02-18T12:45:56.305Z","comments":true,"path":"series/index.html","permalink":"https://blog.zaiyuan.cc/series/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2023-04-25T14:26:25.276Z","updated":"2023-04-25T14:26:25.276Z","comments":true,"path":"tags/index.html","permalink":"https://blog.zaiyuan.cc/tags/index.html","excerpt":"","text":""},{"title":"朋友们","date":"2023-04-25T14:26:25.275Z","updated":"2023-04-25T14:26:25.275Z","comments":true,"path":"friends/index.html","permalink":"https://blog.zaiyuan.cc/friends/index.html","excerpt":"","text":""},{"title":"文章分类","date":"2023-04-25T14:26:25.275Z","updated":"2023-04-25T14:26:25.275Z","comments":true,"path":"categories/index.html","permalink":"https://blog.zaiyuan.cc/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Joplin - github pages","slug":"other/tools/Joplin - github pages","date":"2023-05-04T14:08:49.185Z","updated":"2023-05-04T06:07:28.000Z","comments":true,"path":"other/tools/Joplin - github pages/","link":"","permalink":"https://blog.zaiyuan.cc/other/tools/Joplin%20-%20github%20pages/","excerpt":"","text":"Joplin 导出, hexo 发布到 github pages 支持图片 Joplin 导出 markdown 后有两个文件夹 在 Joplin 里写markdown文章, 直接拖本地图片到编辑区, joplin 会保存图片到_resources文件夹 对指定文件夹 _post 点右键导出 选择 “markdown+文章前言” _post _resources 将这两个文件夹直接 copy 到 hexo 的 source 目录下 调试 hexo 直接 hexo s 运行, 此时会发现有文章生成, 但是图片不显示 debug 后发现生成的文章url与图片路径不匹配 解决办法: 修改文章url12# hexo: / _config.ymlpermalink: :title/ 再次 hexo s, 发现还是没有图片 debug 发现 _resources 文件夹并没有自动copy 解决办法: 配置copy _resources 文件夹123# hexo: / _config.ymlinclude: - _resources/* 此时 hexo s, 即可看到图片 hexo g, 发布, 上传到 github.io 调试 github.io 打开 github pages, 发现还是没有图片 debug 后, 发现还是无法访问_resources 再次检查后, 发现 github.io &gt; setting &gt; pages &gt; build and deployment &gt; deploy from a branch 此选项使用的是 jekyll 来生成 github pages jekyll 默认会跳过 . _ # 等前缀的文件夹 参考 解决办法: 配置 jekyll 参考 在 github.io 根目录下创建 _config.yml 文件 123# github.io: _config.ymlinclude: - _resources 此时重新生成, 就会有图片了 The end","categories":[],"tags":[{"name":"tools","slug":"tools","permalink":"https://blog.zaiyuan.cc/tags/tools/"},{"name":"joplin","slug":"joplin","permalink":"https://blog.zaiyuan.cc/tags/joplin/"}]},{"title":"南传 UNT413a s905l3a","slug":"other/电视盒子/南传 UNT413a s905l3a","date":"2023-05-04T13:49:16.341Z","updated":"2023-04-27T22:17:25.000Z","comments":true,"path":"other/电视盒子/南传 UNT413a s905l3a/","link":"","permalink":"https://blog.zaiyuan.cc/other/%E7%94%B5%E8%A7%86%E7%9B%92%E5%AD%90/%E5%8D%97%E4%BC%A0%20UNT413a%20s905l3a/","excerpt":"","text":"dtc -I dtb -O dts -o meson-g12a-s905l3a-cm311.dts meson-g12a-s905l3a-cm311.dtb dtc -I dtb -O dts -o meson-g12a-s905l3a-m401a.dts meson-g12a-s905l3a-m401a.dtb m401adtc -I dtb -O dts -o meson-g12a-s905l3a-m401a.dts meson-g12a-s905l3a-m401a.dtbdtc -I dts -O dtb -o meson-g12a-s905l3a-m401a.dtb meson-g12a-s905l3a-m401a.dts 7.把你编译好的文件覆盖回原路径cp -f meson-g12a-s905l3a-cm311.dtb &#x2F;boot&#x2F;dtb&#x2F;amlogiccp -f meson-g12a-s905l3a-m401a.dtb &#x2F;boot&#x2F;dtb&#x2F;amlogic 8.保存，重启sync &amp;&amp; reboot","categories":[],"tags":[]},{"title":"note - Joplin 笔记软件","slug":"other/tools/note - Joplin 笔记软件","date":"2023-05-04T13:49:16.337Z","updated":"2023-04-27T23:45:22.000Z","comments":true,"path":"other/tools/note - Joplin 笔记软件/","link":"","permalink":"https://blog.zaiyuan.cc/other/tools/note%20-%20Joplin%20%E7%AC%94%E8%AE%B0%E8%BD%AF%E4%BB%B6/","excerpt":"","text":"Joplin 笔记软件 主要功能&#x2F;特性 markdown 完美支持 markdown 导入导出 可以导出&#x2F;导入markdown 支持 tags, title, created, updated 等特性 的导入&#x2F;导出 可以导出 html 同步 需要下载客户端使用 不能再网页中使用 有如下多种同步模式 可以使用 docker 部署 Joplin Server 进行同步 WebDAV 同步 可以配合 AList 把网盘作为备份盘 可以配合 AList 把服务器目录作为备份盘 1234# ***: alist 服务器地址# /dav: 固定# /joplin : alist 挂载目录http://***/dav/joplin 地址 中文 官网 GitHub","categories":[],"tags":[{"name":"tools","slug":"tools","permalink":"https://blog.zaiyuan.cc/tags/tools/"},{"name":"joplin","slug":"joplin","permalink":"https://blog.zaiyuan.cc/tags/joplin/"}]},{"title":"windows tools","slug":"other/tools/windows tools","date":"2023-05-04T13:49:16.334Z","updated":"2023-02-10T02:02:37.000Z","comments":true,"path":"other/tools/windows tools/","link":"","permalink":"https://blog.zaiyuan.cc/other/tools/windows%20tools/","excerpt":"","text":"1. 下载工具 Motrix 一款全能的下载工具。支持下载 HTTP 、FTP 、BT 、磁力链接等资源。 官网: https://motrix.app/ qbittorrent 据说比 motrix 快 github地址: https://github.com/portapps/qbittorrent-portable 2. 截图软件 snipaste 确实好用 官网地址: https://zh.snipaste.com/ 3. utools 工具合集, 非常好用 快速启动 4. 剪贴板 copyQ 5. 硬件监控 trafficMonitor github: https://github.com/zhongyang219/TrafficMonitor 6. 快速预览 quicklook 空格键预览文件，开源 7. windows 使用时长 Tai 好看 好用 GitHub地址: https://github.com/Planshit/Tai 8. 字体美化 MacTypeTary 官方地址 https://www.mactype.net/","categories":[],"tags":[{"name":"tools","slug":"tools","permalink":"https://blog.zaiyuan.cc/tags/tools/"},{"name":"windows","slug":"windows","permalink":"https://blog.zaiyuan.cc/tags/windows/"}]},{"title":"Visual Studio Code tools","slug":"other/tools/Visual Studio Code tools","date":"2023-05-04T13:49:16.333Z","updated":"2023-02-21T23:55:52.000Z","comments":true,"path":"other/tools/Visual Studio Code tools/","link":"","permalink":"https://blog.zaiyuan.cc/other/tools/Visual%20Studio%20Code%20tools/","excerpt":"","text":"1. Git GitLens 查看行级别的Git提交记录 2. theme GitHub Theme 3. Markdown Markdown All in One markdown 编辑神器 Markdown Preview Enhanced markdown 预览神器 4. Js &#x2F; Ts ESLint 股票基金 韭菜盒子","categories":[],"tags":[{"name":"tools","slug":"tools","permalink":"https://blog.zaiyuan.cc/tags/tools/"},{"name":"vscode","slug":"vscode","permalink":"https://blog.zaiyuan.cc/tags/vscode/"}]},{"title":"dota 梦境伤害","slug":"other/dota/dota 梦境伤害","date":"2023-05-04T13:49:16.332Z","updated":"2023-05-03T18:21:19.000Z","comments":true,"path":"other/dota/dota 梦境伤害/","link":"","permalink":"https://blog.zaiyuan.cc/other/dota/dota%20%E6%A2%A6%E5%A2%83%E4%BC%A4%E5%AE%B3/","excerpt":"","text":"梦境伤害 date boss burt(e) remark 2022-12-16 14:11:38 魔像武者 33.7 2022-12-26 14:01:39 艾雪拉 32 2022-12-27 14:02:33 吸血鬼 37.1 2022-12-28 13:51:17 大地之斧 37.0 2023-01-01 21:58:30 魔像武者 37 2023-01-02 21:58:53 齐天大圣 39.4 2023-01-03 18:03:01 小娜迦 14.7 2023-01-04 18:03:05 生化狂魔 37.1 2023-01-05 09:10:08 深渊 30.1 2023-01-06 15:19:48 毒藤魔女 49.3 2023-01-09 09:32:34 肉山魔王 14.0 2023-01-10 09:33:10 大娜迦 30.2 2023-01-11 10:45:39 艾雪拉 46.3 2023-01-12 13:56:22 吸血鬼 46.4 2023-01-13 15:33:09 大地之斧 33.9 2023-01-14 15:32:05 恶魔天使 39.4 2023-01-15 15:32:27 无畏骑士 38.1 2023-01-16 15:33:52 圣灵守护 41.3 2023-01-17 15:16:29 魔像武者 45.7 2023-01-18 15:17:10 齐天大圣 38.2 2023-01-19 15:17:41 小娜迦 13.3 2023-01-20 15:22:52 2023-01-21 15:23:07 深渊魔王 31.6 2023-01-22 15:27:21 毒藤魔女 55.7 2023-01-23 15:27:51 地狱血魔 47.4 2023-01-24 15:28:41 肉山魔王 24.9 2023-01-25 15:29:04 毒狗 20.2 2023-01-26 15:30:00 美杜莎 45.3 2023-01-27 15:30:20 艾雪拉 43.7 2023-01-28 15:30:50 吸血鬼 48.0 巫医 2023-01-29 15:31:37 大地之斧 42.1 普通 2023-01-30 14:17:05 堕落天使 44.0 2023-01-31 14:17:49 无畏骑士 44.5 巫医, 繁星 2023-02-01 14:18:54 圣灵守护 49.2 巫医 2023-02-02 14:19:22 魔像武者 52.3 巫医 2023-02-03 14:19:56 齐天大圣 64.4 巫医 2023-02-04 21:51:46 小娜迦 24.09 巫医, 繁星 2023-02-05 21:53:01 生化狂魔 38.06 巫医 2023-02-06 21:53:52 深渊魔王 35.89 巫医 2023-02-07 09:14:05 毒藤魔女 73.8 巫医 2023-02-08 09:15:18 地狱血魔 49.7 巫医, 繁星 2023-02-09 09:16:02 肉山魔王 21.8 巫医, 繁星 2023-02-10 09:17:02 毒狗 22 2023-02-11 09:17:44 美杜莎 49.5 2023-02-12 09:18:22 艾雪拉 73.6 巫医 2023-02-28 09:17:20 艾雪拉 78.35 巫医 2023-03-01 09:20:27 吸血鬼 54.97 巫医 2023-03-02 10:00:43 大地之斧 70.37 巫医 2023-03-03 10:01:04 堕落天使 88.5 2023-03-04 10:01:27 无畏骑士 57.22 2023-03-05 09:59:59 圣灵守护 81.83 巫医 2023-03-06 09:59:26 魔像武者 77.24 巫医 2023-03-07 13:33:24 齐天大圣 58.77 2023-03-08 13:34:03 小娜迦 27.26 2023-03-09 13:35:35 生化狂魔 92.54 2023-03-10 18:00:22 深渊魔王 52.27 2023-03-11 18:00:36 毒藤魔女 97.93 2023-03-12 18:00:45 地狱血魔 65.45 2023-03-13 18:00:54 肉山魔王 35.58 2023-03-14 09:03:44 毒狗 27.48 2023-03-15 09:04:31 美杜莎 56.85 2023-03-16 09:06:53 艾雪拉 73.67 2023-03-17 09:04:06 吸血鬼 99.18 2023-03-18 18:02:10 大地之斧 70.56 2023-03-19 18:02:22 堕落天使 99.99 2023-03-20 18:02:31 无畏骑士 65.40 2023-04-23 15:10:21 魔像武者 99.99 2023-04-24 15:10:45 齐天大圣 93.64 2023-04-25 10:28:30 小娜迦 30.5 2023-04-26 09:27:39 生化狂魔 99.99 2023-04-27 09:24:16 深渊魔王 65.31 2023-04-28 22:58:00 毒藤魔女 91.33 2023-04-29 18:00:45 地狱血魔 85.87 2023-04-30 18:00:54 肉山魔王 29.90 2023-05-01 09:03:44 毒狗 23.54 2023-05-02 09:04:31 美杜莎 84.66 2023-05-03 09:06:53 艾雪拉 99.99 小娜迦 巫医，深海，炽翼，赏金，繁星 第一次巫医、炽翼不开大 第二次全开 第三次及以后星深海赏金一起开","categories":[],"tags":[{"name":"dota","slug":"dota","permalink":"https://blog.zaiyuan.cc/tags/dota/"}]},{"title":"docker -- 2. mysql install","slug":"shell/docker/docker -- 2. mysql install","date":"2023-05-04T13:49:16.331Z","updated":"2023-04-27T22:58:35.000Z","comments":true,"path":"shell/docker/docker -- 2. mysql install/","link":"","permalink":"https://blog.zaiyuan.cc/shell/docker/docker%20--%202.%20mysql%20install/","excerpt":"","text":"mysql install创建文件 在要部署的地方, 创建 docker-compose.yaml 文件 创建 mysql 文件夹 编辑 docker-compose12345678910111213141516version: &#x27;3.7&#x27;services: mysql: image: mysql container_name: mysql restart: always ports: - 3306:3306 volumes: - ./mysql/data:/var/lib/mysql - ./mysql/my.cnf:/etc/mysql/my.cnf environment: MYSQL_ROOT_PASSWORD: 123456 TZ: Asia/Shanghai docker run1docker-compose up -d mysql other1docker run -d --name mysql-test -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 mysql 进入mysql1docker exec -it mysql sh update mysql passwrod type123456789101112131415# 进入 mysqlmysql -u root -p# input passwordalter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;123456&#x27; password expire never;# 修改localhost 的验证方式alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified with mysql_native_password by &#x27;123456&#x27;;# 修改外部访问的验证方式, 外部访问直接改这个就行alter user &#x27;root&#x27;@&#x27;%&#x27; identified with mysql_native_password by &#x27;123456&#x27;;# 查看select user,host,plugin,authentication_string from user;","categories":[],"tags":[{"name":"sql","slug":"sql","permalink":"https://blog.zaiyuan.cc/tags/sql/"},{"name":"mysql","slug":"mysql","permalink":"https://blog.zaiyuan.cc/tags/mysql/"},{"name":"docker","slug":"docker","permalink":"https://blog.zaiyuan.cc/tags/docker/"}]},{"title":"docker -- 7. AList 网盘挂载","slug":"shell/docker/docker -- 7. AList 网盘挂载","date":"2023-05-04T13:49:16.329Z","updated":"2023-04-27T22:56:30.000Z","comments":true,"path":"shell/docker/docker -- 7. AList 网盘挂载/","link":"","permalink":"https://blog.zaiyuan.cc/shell/docker/docker%20--%207.%20AList%20%E7%BD%91%E7%9B%98%E6%8C%82%E8%BD%BD/","excerpt":"","text":"AList 网盘挂载 地址 AList GitHub Alist文档 主要功能&#x2F;特点 挂载本地 挂载各种网盘 网页统一访问 支持 WebDAV 协议对外访问 Docker 中使用1234567891011121314version: &#x27;3.7&#x27;services: trilium: image: zadam/trilium container_name: trilium restart: always ports: - 8008:8080 volumes: # 把同文件夹下的 trilium-data 目录映射到容器内 - ./trilium/data:/home/node/trilium-data environment: # 环境变量表示容器内笔记数据的存储路径 - TRILIUM_DATA_DIR=/home/node/trilium-data Docker 下查看admin密码12docker exec -it alist bash./alist admin","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"https://blog.zaiyuan.cc/tags/docker/"}]},{"title":"docker -- 6. trilium 博客系统","slug":"shell/docker/docker -- 6. trilium 博客系统","date":"2023-05-04T13:49:16.322Z","updated":"2023-04-27T22:39:04.000Z","comments":true,"path":"shell/docker/docker -- 6. trilium 博客系统/","link":"","permalink":"https://blog.zaiyuan.cc/shell/docker/docker%20--%206.%20trilium%20%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"trilium 博客系统 地址 中文 github 地址 原版地址 wiki 地址 主要功能(使用几天的感受) 支持 markdown, 但感觉不太多 Trilium 使用了很棒的CKEditor 5作为它的编辑组件。但我感觉不太好用, 可能是不会 可以导出&#x2F;导入markdown, 不是完美兼容 可以导出html 有客户端, 可以在客户端直接编辑, 随后同步到服务器 部署私有服务器, 数据在自己手中 Docker 中使用1234567891011121314version: &#x27;3.7&#x27;services: trilium: image: zadam/trilium container_name: trilium restart: always ports: - 8008:8080 volumes: # 把同文件夹下的 trilium-data 目录映射到容器内 - ./trilium/data:/home/node/trilium-data environment: # 环境变量表示容器内笔记数据的存储路径 - TRILIUM_DATA_DIR=/home/node/trilium-data","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"https://blog.zaiyuan.cc/tags/docker/"}]},{"title":"docker -- 1. Dockerfile","slug":"shell/docker/docker -- 1. Dockerfile","date":"2023-05-04T13:49:16.303Z","updated":"2023-04-06T19:09:18.000Z","comments":true,"path":"shell/docker/docker -- 1. Dockerfile/","link":"","permalink":"https://blog.zaiyuan.cc/shell/docker/docker%20--%201.%20Dockerfile/","excerpt":"","text":"作用 Dockerfile 是用来构建镜像的 Dockerfile 里的每一行, build 的时候都会对应一个 image 调试 思路 dockerfile 里的每一行, build 的时候都会对应一个 image 一个image可以使用 docker create 命令创建一个 container 然后使用 docker export 命令将 container 导出为压缩包 解压即可看到image对应的文件 1234567docker build . -t image1docker create --name pack1 image1docker export pack1 &gt; pack1.tar COPY 命令使用 copy: 从本地路径 copy 到 image 内部 1234567# 设置 image 工作目录为 /srcWORKDIR /src# 第一个. : 本地 Dockerfile 所在路径# 第二个. : image内 /src# 类似于linux: copy ./* /srcCOPY . . copy 只能访问到 Dockerfile 所在目录, 所以: 只能是 COPY . . 不能 COPY .. . 路径说明 12345678910111213141516# Dockerfile 初始本地路径# /root/github/dir1/Dockerfile# /root/github/dir1/***.sln# /root/github/dir1/DM.Log.Service/***.scprojWORKDIR /srcCOPY . .# 此时, image内路径为:# /src/Dockerfile# /src/***.sln# /src/DM.Log.Service/***.# 即: /root/github/dir1/ == /src/WORKDIR &quot;/src/DM.Log.Service/.&quot; copy image 内部文件 1234567FROM build AS publishWORKDIR /app# --from=publish : 设置从 publish image进行copy# /app/publish : image 内部的路径 /app/publish# . : image内部WORKDIR所在路径, /appCOPY --from=publish /app/publish . 示例12345678910111213141516171819202122#See https://aka.ms/containerfastmode to understand how Visual Studio uses this Dockerfile to build your images for faster debugging.FROM mcr.microsoft.com/dotnet/aspnet:6.0 AS baseWORKDIR /appEXPOSE 80EXPOSE 443FROM mcr.microsoft.com/dotnet/sdk:6.0 AS buildWORKDIR /srcCOPY . .WORKDIR &quot;/src/DM.Log.Service/.&quot;RUN dotnet restore &quot;./DM.Log.Service.csproj&quot;RUN dotnet build &quot;./DM.Log.Service.csproj&quot; -c Release -o /app/buildFROM build AS publishRUN dotnet publish &quot;./DM.Log.Service.csproj&quot; -c Release -o /app/publish /p:UseAppHost=falseFROM base AS finalWORKDIR /appCOPY --from=publish /app/publish .ENTRYPOINT [&quot;dotnet&quot;, &quot;DM.Log.Service.dll&quot;]","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"https://blog.zaiyuan.cc/tags/docker/"},{"name":"dockerfile","slug":"dockerfile","permalink":"https://blog.zaiyuan.cc/tags/dockerfile/"}]},{"title":"docker -- 3. ddns-go","slug":"shell/docker/docker -- 3. ddns-go","date":"2023-05-04T13:49:16.301Z","updated":"2023-04-23T23:31:04.000Z","comments":true,"path":"shell/docker/docker -- 3. ddns-go/","link":"","permalink":"https://blog.zaiyuan.cc/shell/docker/docker%20--%203.%20ddns-go/","excerpt":"ddns-gogithub地址 地址: GitHub 主要功能 自动获得你的公网 IPv4 或 IPv6 地址，并解析到对应的域名服务。 主要特性 支持Mac、Windows、Linux系统，支持ARM、x86架构 支持 Docker 中部署; 重要:docker 部署的时候需要使用host模式host模式只能在linux中使用所以只能在 linux 中 Docker 部署 支持的域名服务商 Alidns(阿里云) 支持多个域名同时解析 网页中配置，简单又方便，默认勾选禁止从公网访问 支持Webhook通知","text":"ddns-gogithub地址 地址: GitHub 主要功能 自动获得你的公网 IPv4 或 IPv6 地址，并解析到对应的域名服务。 主要特性 支持Mac、Windows、Linux系统，支持ARM、x86架构 支持 Docker 中部署; 重要:docker 部署的时候需要使用host模式host模式只能在linux中使用所以只能在 linux 中 Docker 部署 支持的域名服务商 Alidns(阿里云) 支持多个域名同时解析 网页中配置，简单又方便，默认勾选禁止从公网访问 支持Webhook通知 Docker 中使用docker run code12345docker run -d --name ddns-go \\--restart=always \\--net=host \\-v ./root:/root \\jeessy/ddns-go 在浏览器中打开http:&#x2F;&#x2F;主机IP:9876，修改你的配置，成功 docker-compose1234567891011version: &#x27;3.7&#x27;services: ddns: image: jeessy/ddns-go container_name: ddns-go restart: always network_mode: host volumes: - ./ddns-go/root:/root environment: TZ: Asia/Shanghai 系统中直接使用 看官网方法 其他功能 看官网","categories":[],"tags":[{"name":"ddns","slug":"ddns","permalink":"https://blog.zaiyuan.cc/tags/ddns/"},{"name":"docker","slug":"docker","permalink":"https://blog.zaiyuan.cc/tags/docker/"}]},{"title":"docker -- 4. nginx","slug":"shell/docker/docker -- 4. nginx","date":"2023-05-04T13:49:16.299Z","updated":"2023-04-24T00:53:32.000Z","comments":true,"path":"shell/docker/docker -- 4. nginx/","link":"","permalink":"https://blog.zaiyuan.cc/shell/docker/docker%20--%204.%20nginx/","excerpt":"nginxgithub地址主要功能主要特性","text":"nginxgithub地址主要功能主要特性 Docker 中使用docker rundocker-compose1234567891011121314version: &#x27;3.7&#x27;services: nginx: image: nginx container_name: nginx restart: always ports: - 8080:80 volumes: - ./nginx/nginx:/etc/nginx - ./nginx/html:/usr/share/nginx/html - ./nginx/logs:/var/log/nginx environment: TZ: Asia/Shanghai","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"https://blog.zaiyuan.cc/tags/docker/"},{"name":"nginx","slug":"nginx","permalink":"https://blog.zaiyuan.cc/tags/nginx/"}]},{"title":"docker -- 5. filebrowser 文件服务器","slug":"shell/docker/docker -- 5. filebrowser 文件服务器","date":"2023-05-04T13:49:16.298Z","updated":"2023-04-24T01:39:26.000Z","comments":true,"path":"shell/docker/docker -- 5. filebrowser 文件服务器/","link":"","permalink":"https://blog.zaiyuan.cc/shell/docker/docker%20--%205.%20filebrowser%20%E6%96%87%E4%BB%B6%E6%9C%8D%E5%8A%A1%E5%99%A8/","excerpt":"filebrowser 文件服务器地址 github地址: GitHub feature: Feature 主要功能 上传文件 浏览文件 分享文件 下载文件 shell 默认账号密码: admin – admin","text":"filebrowser 文件服务器地址 github地址: GitHub feature: Feature 主要功能 上传文件 浏览文件 分享文件 下载文件 shell 默认账号密码: admin – admin Docker 中使用docker run12345678docker run \\ -v /path/to/root:/srv \\ -v /path/to/filebrowser.db:/database/filebrowser.db \\ -v /path/to/settings.json:/config/settings.json \\ -e PUID=$(id -u) \\ -e PGID=$(id -g) \\ -p 8080:80 \\ filebrowser/filebrowser:s6 docker-compose123456789101112version: &#x27;3.7&#x27;services: filebrowser: image: filebrowser/filebrowser:s6 container_name: filebrowser restart: always ports: - 8006:80 volumes: - ./filebrowser/srv:/srv - ./filebrowser/database:/database - ./filebrowser/config:/config","categories":[],"tags":[{"name":"docker","slug":"docker","permalink":"https://blog.zaiyuan.cc/tags/docker/"},{"name":"filebrowser","slug":"filebrowser","permalink":"https://blog.zaiyuan.cc/tags/filebrowser/"}]},{"title":"git 命令小记","slug":"shell/git/git 命令小记","date":"2023-05-04T13:49:16.296Z","updated":"2022-12-02T02:02:50.000Z","comments":true,"path":"shell/git/git 命令小记/","link":"","permalink":"https://blog.zaiyuan.cc/shell/git/git%20%E5%91%BD%E4%BB%A4%E5%B0%8F%E8%AE%B0/","excerpt":"","text":"配置 git config –global user.name “xxxxxx” 配置全局用户名 git config –global user.email “&#120;&#120;&#x78;&#x78;&#x78;&#x78;&#64;&#120;&#120;&#120;&#46;&#x63;&#111;&#109;“ 配置全局用户邮箱 git config –global core.editor vim 配置git 提交信息的编辑器 以上命令省去 –global 可以对单独的项目进行配置 在git的全局配置（~&#x2F;.gitconfig）中可以对 一些命令起别名 在每个git管理的项目中可以假如 .gitignore 文件用来设置 可以被忽略的文件格式 基础命令 git status 查看文件状态 git add 把文件添加到git , 需要添加多个文件时，可以使用 add .或者 add * 来批量添加所有文件 git commit -m “备注信息” git commit -a -m &quot;备注信息&quot; 可以把 已经至少add过一次的所有文件（假如是新文件，就不会被提交）的修改提交 提交文件，并且加上提交时的备注信息，如果不加-m 会进入编辑器界面编辑备注信息 git log 查看历史提交记录 git tag -m”备注” &lt;commit值&gt; 给固定的记录打上标记 git cat-file -p &lt;commit值&gt; 查看指定commit中所包含的内容 tree 是指本次提交中的文件结构 parent 是本次commit的父节点 blob 是具体的文件的对象 撤销修改 git checkout 从历史区中捡出 file 把当前工作区中修改的内容覆盖掉 这样的操作比较危险，误操作时容易把工作区的改动全部删除 git stash 把当前工作区的中修改撤销 ，撤销的修改会以 栈 的形式存放 ，如果需要把撤销再复原的话，可以使用 git stash pop 把撤销拿回来; 如果需要彻底清空 stash里的内容可以 使用 git stash clear来清除垃圾区 git rm 可以把文件从历史区中删除，所以要想从git管理中删除某一个文件，必须使用 git rm，而不是直接使用rm git reset HEAD 可以把已经add到暂存区的修改再撤销回工作区vi 对比文件差异 git diff 分支操作 git branch 列出当前所有分支 1.1 git branch –all &#x2F;&#x2F; 所有的分支 git branch &lt;分支名&gt; 基于当前分支的最新提交拉取一次分支 git checkout &lt;分支名&gt; 切换到指定的分支上去 - 切换远程分支到本地 git checkout -b cad_team_a remotes/origin/cad_team_a git branch -d &lt;分支名&gt; 删除指定的分支 ，如果确定需要删除可以使用 -D 强制删除 git checkout -b &lt;分支名&gt; 会创建并且切换到该分支 git reset –hard &lt;commit值&gt; 可以回退本分支上的某一次 具体的提交 git merge &lt;分支名&gt; merge是把指定分支合并到当前的分支 git merge --no-merged 可以查看当前还有哪些分支与当前分支没有合并的 git merge --merge 可以查看已经与当前分支合并过的分支 git cherry-pick &lt;commit值&gt; 从别的分支上捡出一个commit与当前分支合并 git rebase 重衍（变基）命令 将某个分支的改动直接加入到某一指定分支上冲重新开展，效果是在最终的log里看不到有侧分支的痕迹 1 切换到需要 重衍的 分支 git checkout someBranch （需要重衍的分支） 2 执行重衍命令 git rebase baseBranch (重衍基于的分支) 3 切换到基于的分支合并重衍的分支 git checkout baseBranch &gt; git merge someBranch 远程操作 git clone 克隆远端仓库 基于ssh的远端地址 ssh://qingyun@192.168.1.233:/Users/qingyun/Desktop/code1512/Code/20160128/TestRemote 基于http/https的远端地址 http(https)://xxx.xxx.com/xxxx.git 加 -o 可以给远端仓库改名，默认是 origin git remote 列出远端仓库列表 git remote rename remoteName newName 给远端仓库改名 git remote show 列出远端仓库列表 git remote add &lt;仓库名&gt; &lt;远端地址&gt; 添加新的远端仓库 git remote rm &lt;仓库名&gt; 删除指定远端仓库 git fetch 拉取远端仓库内容 git fetch &lt;仓库名&gt; 拉取指定远端仓库的内容 fetch只是把远端仓库内容下载到本地，如果需要将内容与本地分支合并 需要 git merge &lt;仓库名&gt;/&lt;分支名&gt; git pull &lt;仓库名&gt; &lt;远端分支名&gt; 拉取远端分支并且跟本地分支合并 类似 fetch+merge 的组合 git push &lt;仓库名&gt; &lt;本地分支名&gt; 推送到服务器 git push &lt;仓库名&gt; :&lt;服务器分支名&gt; 删除服务器上的某一分支","categories":[],"tags":[{"name":"git","slug":"git","permalink":"https://blog.zaiyuan.cc/tags/git/"}]},{"title":"linux 下 git 免密","slug":"shell/git/linux 下 git 免密","date":"2023-05-04T13:49:16.295Z","updated":"2022-09-20T19:14:00.000Z","comments":true,"path":"shell/git/linux 下 git 免密/","link":"","permalink":"https://blog.zaiyuan.cc/shell/git/linux%20%E4%B8%8B%20git%20%E5%85%8D%E5%AF%86/","excerpt":"","text":"方法一 cd到~&#x2F;目录下，创建一个文件：touch .git-credentialsvim .git-credentials 然后输入https:&#x2F;&#x2F;{username}:{password}@git.gitxx.com，比如http://fengjiaheng:password@git.gitxx.com 然后执行：git config –global credential.helper store 然后使用git config –list或者查看一下~&#x2F;.gitconfig文件，会发现多了一行[credential] helper &#x3D; store 这时候再用 git 拉取仓库就不需要输入用户名和密码了。注意：第4步必须要做，否则做完4、5步之后也不能免密码拉取成功，需要再次执行第4步骤。 方法二 粗暴使用型Git Clone命令直接使用用户名密码Clone git clone http://userName:password@链接修改为 git clone https://username:password@链接 示例：git clone git@http://112.12.122.22:t-mapi/hotel-tapi.git修改为git clone ‘http://username:password@112.12.122.22:t-mapi/hotel-tapi.git’ 注意事项（2）如果账号username或者password中有@符号,需要 将@替换为%40（3）如果报错git clone event not found，需要将 git clone 后地址加上引号 ‘’","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://blog.zaiyuan.cc/tags/linux/"},{"name":"git","slug":"git","permalink":"https://blog.zaiyuan.cc/tags/git/"}]},{"title":"Create Hexo","slug":"shell/hexo/Create Hexo","date":"2023-05-04T13:49:16.293Z","updated":"2022-09-19T06:34:05.000Z","comments":true,"path":"shell/hexo/Create Hexo/","link":"","permalink":"https://blog.zaiyuan.cc/shell/hexo/Create%20Hexo/","excerpt":"","text":"安装 安装前提: nodejs 安装 nodejs 直接下载安装: Nodejs 安装 hexo1npm install -g hexo-cli 初始化项目 找个文件夹1hexo init 使用 vexo theme theme 地址: Vexo Download&#x2F;Checkout this theme into your project 12345cd your-hexo-foldergit clone https://github.com/yanm1ng/hexo-theme-vexo.git themes/vexocp -R themes/vexo/_source/* source/ Update project _config.yml theme config, look like this 1themes: vexo Here theme’s name must same as the theme folder name. Modify theme themes/vexo/_config.yml with your own info. 创建新文章1hexo new &quot;title&quot; 发布 测试, 查看效果 hexo server 生成到 public 文件夹 hexo g copy public 里的内容到 github.io 项目, 并提交 最后, 提交本项目更改","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://blog.zaiyuan.cc/tags/hexo/"}]},{"title":"Hello World","slug":"shell/hexo/Hello World","date":"2023-05-04T13:49:16.291Z","updated":"2022-09-19T06:34:04.000Z","comments":true,"path":"shell/hexo/Hello World/","link":"","permalink":"https://blog.zaiyuan.cc/shell/hexo/Hello%20World/","excerpt":"","text":"Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://blog.zaiyuan.cc/tags/hexo/"}]},{"title":"linux -- linux cmd","slug":"shell/linux/linux -- linux cmd","date":"2023-05-04T13:49:16.290Z","updated":"2023-04-27T22:27:50.000Z","comments":true,"path":"shell/linux/linux -- linux cmd/","link":"","permalink":"https://blog.zaiyuan.cc/shell/linux/linux%20--%20linux%20cmd/","excerpt":"","text":"查看系统信息 uname -a 查看硬盘情况df -h du -h /root 列举 /root 下所有目录 及子目录文件/文件夹大小 du -sh /root /root 大小 du -sh * 查看当前目录下, 所有大小 查看ip1ifconfig -all 重启1reboot 关机1shutdown -h now","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://blog.zaiyuan.cc/tags/linux/"}]},{"title":"linux -- ubuntu config root","slug":"shell/linux/linux -- ubuntu config root","date":"2023-05-04T13:49:16.288Z","updated":"2022-12-26T19:46:48.000Z","comments":true,"path":"shell/linux/linux -- ubuntu config root/","link":"","permalink":"https://blog.zaiyuan.cc/shell/linux/linux%20--%20ubuntu%20config%20root/","excerpt":"","text":"1. 修改 sshd_config123456cd /etc/sshvim sshd_config# 找到 Authentication 下的 PermitRootLogin prohibit-password#修改为:PermitRootLogin yes 2. 重启 ssh1/etc/init.d/ssh restart 3. 重置 root 用户的密码 Ubuntu的默认root密码是随机的，即每次开机都有一个新的root密码 切换到普通用户 sudo passwd 根据提示输入当前用户的密码, 然后重置 root 的new密码 看到 password updated successfully, 就是重置好了","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"https://blog.zaiyuan.cc/tags/linux/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://blog.zaiyuan.cc/tags/ubuntu/"}]},{"title":"用chrome浏览器 下载 fir.im 的 ipa - 简书","slug":"code/iOS/用chrome浏览器 下载 fir.im 的 ipa - 简书","date":"2023-05-04T13:49:16.287Z","updated":"2023-04-28T00:37:26.000Z","comments":true,"path":"code/iOS/用chrome浏览器 下载 fir.im 的 ipa - 简书/","link":"","permalink":"https://blog.zaiyuan.cc/code/iOS/%E7%94%A8chrome%E6%B5%8F%E8%A7%88%E5%99%A8%20%E4%B8%8B%E8%BD%BD%20fir.im%20%E7%9A%84%20ipa%20-%20%E7%AE%80%E4%B9%A6/","excerpt":"","text":"在浏览器上输入下载地址 进入调试模式 用调试模式里的手机模式重新加载, 选iPhone机型, 如图所示 点击下载安装, console 会弹出一条报错信息 点击报错信息, 浏览器会弹出新页面打开 复制地址的后半段 https 以后的, 如图 使用地址解析解析出 install 下载地址, 打开下载地址 下载出 install 文件后, 用 文本文档打开, 从中找到真正的下载地址 下载ipa the end!","categories":[],"tags":[]},{"title":"代码 与 \"遗传学\" \"进化论\"","slug":"code/iOS/代码 与 _遗传学_ _进化论_","date":"2023-05-04T13:49:16.283Z","updated":"2023-04-28T01:21:16.000Z","comments":true,"path":"code/iOS/代码 与 _遗传学_ _进化论_/","link":"","permalink":"https://blog.zaiyuan.cc/code/iOS/%E4%BB%A3%E7%A0%81%20%E4%B8%8E%20_%E9%81%97%E4%BC%A0%E5%AD%A6_%20_%E8%BF%9B%E5%8C%96%E8%AE%BA_/","excerpt":"","text":"前言前几天我看了一篇文章, 讲的就是这个, 深有感触, 于是自己用代码撸了一遍 先讲故事 (故事是根据之前的文章写的) 有一块沙滩, 上面住着很多的贝壳 , 贝壳的壳上有着各种的图案. 有一天村民发现了这里, 开始捡贝壳回家…, 贝壳跟村民回家后的待遇大伙们都懂… 但是村民不是什么贝壳都捡, 村民家里有信仰的图腾, 当发现贝壳的图案与图腾比较像的时候就跳过, 村民会留下一部分让贝壳们繁衍生息 就这样过了 n 代以后 , 你会发现每个贝壳的壳上都长着与图腾很像的图案. 故事讲完了, 这就是 遗传学 进化论 的神奇之处 , 下来我用代码来模拟这一过程 定义123456789101112131415/// 种群最大数let populationMaxCount = 100;/// 种群被筛选后剩余最小数let populationMinCount = 30;/// 每个 unit 特征个数let unitDNACount = 100;/// 突变概率, 20 代表 20% , 即: 生成model会产生突变的概率;let mutationRate = 60;/// 算法按 相同 算还是 相似 算let isEqualCount = true;/// 输出结果是按 线 输出还是按 点 输出let isDrawLine = false; 主要循环 :繁衍生息 &gt;&gt; 排序 &gt;&gt; 剔除不像的 &gt;&gt; 输出最像的 &gt;&gt; 是否继续 &gt;&gt; 繁衍生息 12345678910func runLoop(block:(_ datas:[HeredityModel] , _ times:Int)-&gt;Bool) &#123; var isGoOn = true; while isGoOn &#123; makeChilds(); sort(); weedOut(); times += 1; isGoOn = block(datas,times); &#125; &#125; 繁衍生息 当少于种群最大值时就繁殖 在剩余种群中 找出一对父母 进行繁育 1234567891011121314151617// 繁衍生息 func makeChilds() &#123; while datas.count &lt; populationMaxCount - 1 &#123; birthChild(); &#125; &#125; // 造人 func birthChild() &#123; let half = populationMinCount / 2; let mother = datas[Int(arc4random()) % half]; // 前半数组中取一个 let father = datas[Int(arc4random()) % half + half]; // 后半数组中取一个 let child = HeredityModel(father, mother); child.makeLikeCount(base: baseModel); datas.append(child); &#125; 造物过程 取父与母的随机一个 DNA 进行遗传 (遗传学中 DNA 是根据显性与隐性来遗传的, 代码中就用随机来代表了) 根据概率计算其是否需要变异 (没有变异, 物种就不会进化) 随机计算要进化的 DNA 的位置 123456789101112131415init(_ model1:HeredityModel ,_ model2:HeredityModel) &#123; let isMutation = arc4random() % 100 &lt; mutationRate; //是否进行突变 let index = isMutation ? Int(arc4random()) % unitDNACount : -1; // 突变位置 for i in 0...unitDNACount-1 &#123; if i == index &#123; // 突变 models.append(HereditySubModel()); &#125; else &#123; // 正常遗传 let random = arc4random() % 2; let model = random == 1 ? model2 : model1; models.append(model.models[i]); &#125; &#125;&#125; 相似度计算 基准 DNA 我是画了一条45°的直线 按 DNA 相似计算 (物种会很快取向相似 , 并且越来越相似) 按 DNA 相同计算 (物种多样性会更好 , 很久以后也存在跳脱的) 1234567891011121314func makeLikeCount(base:HeredityModel) &#123; likeCount = 0; for i in 0...unitDNACount-1 &#123; if isEqualCount &#123; // 按基因相同计算 if (self.models[i].x == base.models[i].x &amp;&amp; self.models[i].y == base.models[i].y) &#123; likeCount += 1; &#125; &#125; else &#123; // 按基因相似计算 likeCount += unitDNACount - abs(self.models[i].x - base.models[i].x); likeCount += unitDNACount - abs(self.models[i].y - base.models[i].y); &#125; &#125; &#125; 成果展示 基准 DNA 我是画了一条45°的直线 按 DNA 相似计算 经过 98239 代繁育 , 终于进化出完美的 DNA 按 DNA 相同计算 总共繁衍了 100000 代 , 在 85555 代的时候已经繁衍出相同数 99 的物种了 ,最终也没有进化出完美的 , 并不是说这种进化不出 , 只是运气问题而已 总结通过调整 定义值 , 会有不同的变化 , 通过这些变化可以看到 进化论 中很多神奇的进化过程 .喜欢的同学可以自己下载演示: 源码地址 &#x2F;&#x2F; MacOS代码","categories":[],"tags":[{"name":"code","slug":"code","permalink":"https://blog.zaiyuan.cc/tags/code/"},{"name":"ios","slug":"ios","permalink":"https://blog.zaiyuan.cc/tags/ios/"}]},{"title":"KMP 算法小记","slug":"code/算法/KMP 算法小记","date":"2023-05-04T13:49:16.279Z","updated":"2023-04-28T00:40:48.000Z","comments":true,"path":"code/算法/KMP 算法小记/","link":"","permalink":"https://blog.zaiyuan.cc/code/%E7%AE%97%E6%B3%95/KMP%20%E7%AE%97%E6%B3%95%E5%B0%8F%E8%AE%B0/","excerpt":"","text":"KMP 算法 主要是用来从一个主串s中查找子串p的位置 要从 s 中找 p 首先想到的就是暴力搜索暴力搜索示例:s &#x3D; “abcdabce”p &#x3D; “bce” step 1: 12abcdabcebce a &#x3D;&#x3D; b ? 不相等, 则next setp 2: 12abcdabce bce b&#x3D;&#x3D;b ? c&#x3D;&#x3D;c ? d&#x3D;&#x3D;e? 显然 d!&#x3D;e , next step 3:12abcdabce bce c &#x3D;&#x3D; b ? 不相等 , next ……直至到最后找出结果 这么做的话会发现比较浪费, 在 setp 2中, p中的 b与c 都比较过了,能不能想办法不再比较 b 与c 了, 这个办法就是 kmp 下面给出 swift 版本代码 : 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Solution &#123; var next: [Int] = []; func kmpSearch(_ s: String ,_ p: String) -&gt; Int &#123; next = getNext(p); let sLen = s.count; let pLen = p.count; let s = s.cString(using: .utf8); let p = p.cString(using: .utf8); var i = 0; var j = 0; while (i &lt; sLen &amp;&amp; j &lt; pLen ) &#123; // 当 p 与 s 第一个字符都不匹配的时候 (j == -1) // 或当 p 与 s 当前字符匹配成功 (s?[i] == p?[j]) // 则进行下一个字符匹配 if j == -1 || s?[i] == p?[j] &#123; i += 1; j += 1; &#125; else &#123; // 如果 当前字符匹配失败（即S[i] != P[j]），则令 i 不变，j = next[j] // next[j] 即为 j 所对应的 next 值 j = next[j]; &#125; &#125; if j == pLen &#123; return i - j; &#125; return -1; &#125; func getNext(_ p: String ) -&gt; [Int] &#123; let len = p.count; let p = p.cString(using: .utf8); var next = Array.init(repeating: 0, count: len); next[0] = -1; var k = -1; var j = 0; while j &lt; len - 1 &#123; //p[k]表示前缀，p[j]表示后缀 if (k == -1 || p?[j] == p?[k]) &#123; j += 1; k += 1; if p?[j] != p?[k] &#123; next[j] = k; &#125; else &#123; //因为不能出现p[j] = p[next[j ]]，所以当出现时需要继续递归，k = next[k] = next[next[k]] next[j] = next[k]; &#125; &#125; else &#123; k = next[k]; &#125; &#125; return next; &#125;&#125;let so = Solution();let result = so.kmpSearch(&quot;abaabababaaababaabaa&quot;,&quot;aabaa&quot;);print(result); 原文地址 : 从头到尾彻底理解KMP通读了两遍 , 大概理解了 , 脑袋记不住只能存下来了","categories":[],"tags":[]},{"title":"算法 : Rabin-Karp 字符串编码","slug":"code/算法/算法 _ Rabin-Karp 字符串编码","date":"2023-05-04T13:49:16.277Z","updated":"2023-04-28T00:49:12.000Z","comments":true,"path":"code/算法/算法 _ Rabin-Karp 字符串编码/","link":"","permalink":"https://blog.zaiyuan.cc/code/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%20_%20Rabin-Karp%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%BC%96%E7%A0%81/","excerpt":"","text":"先看一个题目 「快乐前缀」是在原字符串中既是 非空 前缀也是后缀（不包括原字符串自身）的字符串。给你一个字符串 s，请你返回它的 __最长快乐前缀__。如果不存在满足题意的前缀，则返回一个空字符串。 示例 1：输入：s &#x3D; “level”输出：”l”解释：不包括 s 自己，一共有 4 个前缀（”l”, “le”, “lev”, “leve”）和 4 个后缀（”l”, “el”, “vel”, “evel”）。最长的既是前缀也是后缀的字符串是 “l” 。 示例 2：输入：s &#x3D; “ababab”输出：”abab”解释：”abab” 是最长的既是前缀也是后缀的字符串。题目允许前后缀在原字符串中重叠。 提示：1 &lt;&#x3D; s.length &lt;&#x3D; 10^5s 只含有小写英文字母 看完这个题后 , 觉得挺简单的, 为啥给了难度:困难 呢 分析一下 : 从字符串长度-1开始取前缀和后缀,判断是否相等,然后不相等的话长度再-1,再次取值比较当前缀与后缀相同的时候完成 例如 s &#x3D; “ababab”;可以写个循环step 1: pre &#x3D; “ababa”; suf &#x3D; “babab”; 不相等, nextstep 2: pre &#x3D; “abab”; suf &#x3D; “abab” 相等 , 找到答案 , so easy 用代码实现: 1234567891011121314151617class Solution &#123; func longestPrefix(_ s: String) -&gt; String &#123; if s.count &lt;= 1 &#123; return &quot;&quot;; &#125; for i in 0...s.count-2 &#123; let pre = s.prefix(s.count-1-i); let suf = s.suffix(s.count-1-i); if pre == suf &#123; return String(pre); &#125; &#125; return &quot;&quot;; &#125;&#125; 多么的完美, 直接提交 , 结果不出意料的 超时! 分析一下,感觉逻辑完美, 为什么会超时呢 据我的分析 pre &#x3D;&#x3D; suf 这一句当字符串很长的时候,耗时严重,当判断两个字符串是否相等的时候, 会把__两个字符串每一位每一位的比较__,当发现有某一位不一样的时候, 就说明字符串不相同, 所以耗时很严重 ##怎么解决呢, 请出今天的主角: Rabin-Karp 字符串编码 背景知识:Rabin-Karp 字符串编码是一种将字符串映射成整数的编码方式，可以看成是一种哈希算法。具体地，假设字符串包含的字符种类不超过 ∣Σ∣（其中 Σ 表示字符集），那么我们选一个大于等于 ∣Σ∣ 的整数 base，就可以将字符串看成 base进制 的整数，将其转换成十进制数后，就得到了字符串对应的编码。 例如: 给定字符串 s &#x3D; “abca”，其包含的字符种类为 3（即 abc三种）。我们取 base &#x3D; 9，将字符串 s 看成九进制数 (0120)9 ，转换为十进制为 90，也就是说字符串 abca 的编码为 90。 这样做的好处是什么？我们可以发现一个结论： 两个字符串 s1 和 s2 相等，当且仅当它们的长度相等且编码值相等。 只考虑小写的情况下, 小写字母26个, 定义&gt;&#x3D;26进制的编码就可以了.例如 “abcdef” &#x3D; (012345)26 但是聪明的同学会发现个问题:当字符串长度变长的时候, 这个编码值会非常大, 这样可能就无法用一般语言中的整数类型（例如 int，long long 等）存储编码值了。对此，一般的解决方法是将编码值对一个数 mod 进行取模，使得其保持在整数类型的范围之内。 但这样就带来了一个问题，两个不相同但长度相等的字符串在取模前会有不同的编码值，在取模后的编码值就有可能相同了。换句话说，我们的编码方式不是单射，这种哈希算法会产生碰撞。然而我们并不需要过分担心这个问题：只要我们将模数设置得很大，并且多选择一些模数，Rabin-Karp 字符串编码产生哈希碰撞的概率就微乎其微。一般来说，对于算法题而言，我们只需要选择一个模数即可，并且它最好是一个__质数__，例如 10^9+7。如有需要，还可以选择第二个模数 10^9+9 。对于前文提到的 __base，一般也选择一个质数__，例如本题中 ∣Σ∣&#x3D;26（即所有小写英文字母），我们可以选择 base&#x3D;31 (&gt;&#x3D; 26的质数)。 算法对于这道题而言:设定: base &#x3D; 31; mod &#x3D; 1000000007; &#x2F;&#x2F; 10^9+7 我们从小到大枚举前缀的长度 i。然后计算 i 对应的前缀编码值和后缀编码值。如果这两个编码值相等，我们就可以判定该前缀和后缀相等。 对于前缀而言，每在字符串最后多出一个新的字符，就相当于原编码值乘以 base 再加上新的字符的编码值； 例如bcd,b &#x3D; (1) 31 &#x3D; b;bc &#x3D; (12)31 &#x3D; (1 * 31 + 2)10 &#x3D; b * 31 + cbcd &#x3D; (123)31 &#x3D; (1 * 31 * 31 + 2 * 31 + 3) &#x3D; (b * 31 * 31 + c * 31 + d) &#x3D; (b * 31 + c) * 31 + d &#x3D; bc*31+d 对于后缀而言，每在字符串最前多出一个新的字符，就相当于原编码值加上新的字符的编码值乘以 base 的 i-1 次幂。 例如bcd,d &#x3D; (3) 31 &#x3D; d;cd &#x3D; (23)31 &#x3D; (2 * 31 + 3)10 &#x3D; c * 31 + dbcd &#x3D; (123)31 &#x3D; (1 * 31 * 31 + 2 * 31 + 3) &#x3D; (b * 31 * 31 + c * 31 + d) &#x3D; b * 31 * 31 + cd 到此就到了最重要的写代码环节了: 12345678910111213141516171819202122232425262728293031323334class Solution &#123; func longestPrefix(_ s: String) -&gt; String &#123; let base = 31; // 大于取值范围的质数 , 代表 31 进制 let mod = 1000000007; let n = s.count; let s = s.cString(using: .utf8) ?? []; let a = 97; var preValue = 0; // 前缀值 var sufValue = 0; // 后缀值 var mul = 1; // mul = (base)的 n-1 次方 var happy = -1; for i in 0..&lt;n-1 &#123; preValue = (preValue * base + Int(s[i])-a)%mod; sufValue = (sufValue + (Int(s[n-i-1])-a) * mul)%mod; if preValue == sufValue &#123; happy = i; &#125; // 每计算一次 mul * base; mul = base ^ i mul = mul * base % mod; &#125; if (happy &lt; 0) &#123; return &quot;&quot;; &#125; else &#123; return String(String.init(cString: s).prefix(happy+1)); &#125; &#125;&#125; 同样是循环比较每个子串是否相等, 这样的效率会高很多…… The End这是我学习LeetCode上的知识的一个总结 , 并非原版照抄 , 原版十分生硬, 看了好久才看明白…赋原文链接: LeetCode原文","categories":[],"tags":[]},{"title":"sql -- cursor","slug":"code/sql/sql -- cursor","date":"2023-05-04T13:49:16.276Z","updated":"2023-02-07T22:59:06.000Z","comments":true,"path":"code/sql/sql -- cursor/","link":"","permalink":"https://blog.zaiyuan.cc/code/sql/sql%20--%20cursor/","excerpt":"","text":"open_cursor 查看所有游标 1SELECT * FROM v$open_cursor ORDER BY LAST_SQL_ACTIVE_TIME DESC 查看游标 sql_text 执行次数 123SELECT SQL_TEXT, COUNT(SQL_TEXT) times FROM v$open_cursor GROUP BY SQL_TEXTORDER BY times DESC FIND WHICH SESSION IN USING MORE CURSORS. 1234SELECT sid,user_name, COUNT(*) &quot;Cursors per session&quot;FROM v$open_cursor where user_name not like &#x27;SYS&#x27;GROUP BY sid,user_nameORDER BY &quot;Cursors per session&quot; DESC; Find which SQL is using more cursors 12345select sid, sql_id ,sql_text, count(*) as &quot;OPEN CURSORS&quot;, USER_NAME from v$open_cursor--where sid in (&#x27;&amp;SID&#x27;) GROUP BY SID,SQL_TEXT,USER_NAME,sql_idORDER BY &quot;OPEN CURSORS&quot; DESC; 游标最大数 123456select p.value as max_open_curfrom v$sesstat a, v$statname b, v$parameter pwhere a.statistic# = b.statistic#and b.name = &#x27;opened cursors current&#x27;and p.name= &#x27;open_cursors&#x27;group by p.value;","categories":[],"tags":[{"name":"sql","slug":"sql","permalink":"https://blog.zaiyuan.cc/tags/sql/"},{"name":"cursor","slug":"cursor","permalink":"https://blog.zaiyuan.cc/tags/cursor/"}]},{"title":"vue1 -- vue cli create project","slug":"code/vue/vue1 -- vue cli create project","date":"2023-05-04T13:49:16.273Z","updated":"2023-01-30T05:18:55.000Z","comments":true,"path":"code/vue/vue1 -- vue cli create project/","link":"","permalink":"https://blog.zaiyuan.cc/code/vue/vue1%20--%20vue%20cli%20create%20project/","excerpt":"","text":"1. install123456789101112# 初始化项目依赖文件npm init -y # 安装脚手架cnpm i -D @vue/cli# 查看vuecli版本npx vue -V# 创建项目 貌似只能小写npx vue create project-one 安装 cnpm npm install -g cnpm –registry&#x3D;https://registry.npm.taobao.org 2. config vue.config.js12345678const &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;)module.exports = defineConfig(&#123; transpileDependencies: true, devServer: &#123; open: true, host: &quot;localhost&quot; &#125;&#125;)","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://blog.zaiyuan.cc/tags/vue/"},{"name":"vue_cli","slug":"vue-cli","permalink":"https://blog.zaiyuan.cc/tags/vue-cli/"}]},{"title":"vue2 -- add element ui / plus","slug":"code/vue/vue2 -- add element ui _ plus","date":"2023-05-04T13:49:16.271Z","updated":"2023-01-31T01:27:23.000Z","comments":true,"path":"code/vue/vue2 -- add element ui _ plus/","link":"","permalink":"https://blog.zaiyuan.cc/code/vue/vue2%20--%20add%20element%20ui%20_%20plus/","excerpt":"","text":"1. installnpm 安装 1npm i element-ui -S 2. 完整引入1234567891011121314import Vue from &#x27;vue&#x27;import App from &#x27;./App.vue&#x27;import ElementUI from &#x27;element-ui&#x27;import &#x27;element-ui/lib/theme-chalk/index.css&#x27;Vue.use(ElementUI)Vue.config.productionTip = falsenew Vue(&#123; render: h =&gt; h(App),&#125;).$mount(&#x27;#app&#x27;) 3. use1234567891011&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;hello&lt;/h1&gt; &lt;el-button&gt;hello&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot;&gt;primary&lt;/el-button&gt; &lt;el-button type=&quot;info&quot;&gt; info &lt;/el-button&gt; &lt;el-button type=&quot;danger&quot;&gt;danger&lt;/el-button&gt; &lt;el-button type=&quot;success&quot;&gt;success&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt; 4. vue3 用的是 element plus 官网 https://element-plus.gitee.io/zh-CN/ 安装 1npm install element-plus --save 使用 main.ts 123456789import &#123; createApp &#125; from &#x27;vue&#x27;import ElementPlus from &#x27;element-plus&#x27;import &#x27;element-plus/dist/index.css&#x27;import App from &#x27;./App.vue&#x27;const app = createApp(App)app.use(ElementPlus)app.mount(&#x27;#app&#x27;) 使用 icon, 需要安装与引用地址: https://element-plus.gitee.io/zh-CN/component/icon.html","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://blog.zaiyuan.cc/tags/vue/"},{"name":"element_ui","slug":"element-ui","permalink":"https://blog.zaiyuan.cc/tags/element-ui/"}]},{"title":"vue3 -- add add sass","slug":"code/vue/vue3 -- add add sass","date":"2023-05-04T13:49:16.270Z","updated":"2023-01-31T18:13:01.000Z","comments":true,"path":"code/vue/vue3 -- add add sass/","link":"","permalink":"https://blog.zaiyuan.cc/code/vue/vue3%20--%20add%20add%20sass/","excerpt":"","text":"1. installnpm 安装 1npm i node-sass sass-loader -D 2. 此处安装可能出问题, 用下面方法可能能解决 管理员身份运行 powershell1npm install --global --producttion windows-build-tools 3. use1234567891011121314151617181920&lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;h1&gt;hello&lt;/h1&gt; &lt;el-button&gt;hello&lt;/el-button&gt; &lt;el-button type=&quot;primary&quot;&gt;primary&lt;/el-button&gt; &lt;el-button type=&quot;info&quot;&gt; info &lt;/el-button&gt; &lt;el-button type=&quot;danger&quot;&gt;danger&lt;/el-button&gt; &lt;el-button type=&quot;success&quot;&gt;success&lt;/el-button&gt; &lt;/div&gt;&lt;/template&gt;&lt;style lang=&quot;scss&quot;&gt;.hello&#123; background: yellow; .el-button&#123; color: red; &#125;&#125;&lt;/style&gt; 4. reset.css 在 src&gt;assets&gt;css 下创建reset.css文件 粘贴下面内容123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/* http://meyerweb.com/eric/tools/css/reset/ v2.0 | 20110126 License: none (public domain)*/html, body, div, span, applet, object, iframe,h1, h2, h3, h4, h5, h6, p, blockquote, pre,a, abbr, acronym, address, big, cite, code,del, dfn, em, img, ins, kbd, q, s, samp,small, strike, strong, sub, sup, tt, var,b, u, i, center,dl, dt, dd, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot, thead, tr, th, td,article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary,time, mark, audio, video &#123; margin: 0; padding: 0; border: 0; font-size: 100%; font: inherit; vertical-align: baseline;&#125;/* HTML5 display-role reset for older browsers */article, aside, details, figcaption, figure, footer, header, hgroup, menu, nav, section &#123; display: block;&#125;body &#123; line-height: 1;&#125;ol, ul &#123; list-style: none;&#125;blockquote, q &#123; quotes: none;&#125;blockquote:before, blockquote:after,q:before, q:after &#123; content: &#x27;&#x27;; content: none;&#125;table &#123; border-collapse: collapse; border-spacing: 0;&#125; 在 App.vue 文件里 &lt; style&gt; 第一行加 @import12345678910&lt;style lang=&quot;scss&quot;&gt;@import url(&#x27;./assets/css/reset.css&#x27;);#app &#123; font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; /* margin-top: 60px; */&#125;","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://blog.zaiyuan.cc/tags/vue/"},{"name":"sass","slug":"sass","permalink":"https://blog.zaiyuan.cc/tags/sass/"}]},{"title":"vue4 -- add axios","slug":"code/vue/vue4 -- add axios","date":"2023-05-04T13:49:16.268Z","updated":"2023-02-10T00:12:20.000Z","comments":true,"path":"code/vue/vue4 -- add axios/","link":"","permalink":"https://blog.zaiyuan.cc/code/vue/vue4%20--%20add%20axios/","excerpt":"","text":"1. axios axios 是用来网络请求的 2. 安装1npm install --save axios 3. 使用axios &#x2F; 封装 request.ts1234567891011121314151617181920212223242526272829303132333435363738// request.ts// 导入import axios from &quot;axios&quot;;// import * as tools from &#x27;./tools&#x27;;// 创建实例const request = axios.create(&#123; // baseURL: &#x27;/api&#x27;, baseURL: &#x27;https://localhost:6001&#x27;, timeout: 5000&#125;);// 请求拦截器request.interceptors.request.use((config) =&gt; &#123; config.headers[&quot;x-requestid&quot;] = tools.Random(99999, 9999999); return config;&#125;, (error) =&gt; &#123; return Promise.reject(error);&#125;);// 返回拦截器request.interceptors.response.use((response) =&gt; &#123; if (response.status == 200) &#123; // todo &#125; return response;&#125;, (error) =&gt; &#123; return Promise.reject(error);&#125;);// 导出接口方法export function LogDotaGetDeviceList() &#123; return request(&#123; url: &quot;/LogDota/GetDeviceList&quot;, method: &quot;GET&quot; &#125;)&#125; tools.ts (非必要)12345// tools.tsexport function Random(min: number, max: number ) &#123; return Math.floor(Math.random() * (max - min)) + min;&#125; 4.使用 request.ts123456789101112131415161718&lt;script lang=&quot;ts&quot;&gt;import &#123; defineComponent &#125; from &#x27;vue&#x27;;import * as request from &quot;@/assets/common/request&quot;;export default defineComponent(&#123; created() &#123; request.LogDotaGetDeviceList() .then(res =&gt; &#123; console.log(res); &#125;) .catch(err =&gt; &#123; console.error(err); &#125;) &#125;&#125;)&lt;/script&gt;","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://blog.zaiyuan.cc/tags/vue/"}]},{"title":"vue5 -- 配置跨域","slug":"code/vue/vue5 -- 配置跨域","date":"2023-05-04T13:49:16.266Z","updated":"2023-02-10T02:02:37.000Z","comments":true,"path":"code/vue/vue5 -- 配置跨域/","link":"","permalink":"https://blog.zaiyuan.cc/code/vue/vue5%20--%20%E9%85%8D%E7%BD%AE%E8%B7%A8%E5%9F%9F/","excerpt":"","text":"1. 概念 同源策略： 是一种约定，web 与 获取的数据同源, 才能被当前web接受&#x2F;运行 它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。 为什么会有不同源: 在前后端分离的模式下，web 服务器 和 资源服务器会分开部署 前后端的域名是不一致的，此时就会发生跨域访问问题 跨域是什么： 浏览器从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域 即使域名相同, 端口不同 也是跨域的。 2. 跨域处理 正规情况下, 需要后端配置跨域规则, 在后端把前端的地址端口配置进去即可 请求示例 1234567891011Host: 192.168.52.21:8001Connection: keep-aliveAccept: */*Access-Control-Request-Method: GETAccess-Control-Request-Headers: x-requestidOrigin: http://192.168.52.21:8080User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Safari/537.36Sec-Fetch-Mode: corsReferer: http://192.168.52.21:8080/Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9 返回示例 12345678HTTP/1.1 204 No ContentDate: Fri, 10 Feb 2023 08:25:38 GMTServer: KestrelAccess-Control-Allow-Credentials: trueAccess-Control-Allow-Headers: x-requestidAccess-Control-Allow-Methods: GETAccess-Control-Allow-Origin: http://192.168.52.21:8080Vary: Origin 3. 伪跨域 但是作为vue前端开发者, 可能主导不了要访问的后端, 开发的时候还必须跨域访问, 然后就有了伪跨域 vue 伪跨域原理 123451. vue 可以配置一个代理, 这个代理是跟前端地址同源的2. 在启动调试的时候, 会同时启动这个代理服务3. 然后请求后台的时候, 把地址配置成这个代理服务, 请求这个代理服务; 4. 在代理服务中配置真正的后台地址, 代理服务再请求到真正的后台; 5. 后台返回数据后, 代理服务 返回到当前页面; vue 伪跨域实现 配置代理服务 123456789101112131415// vue.config.jsconst &#123; defineConfig &#125; = require(&#x27;@vue/cli-service&#x27;)module.exports = defineConfig(&#123; devServer: &#123; proxy: &#123; // 配置跨域, 开启一个代理服务 &#x27;/api&#x27;: &#123; // 代理服务的地址: /api target:&#x27;http://192.168.52.21:8001&#x27;, // 真正的后台地址 changOrigin: true, // 同意跨域 pathRewrite: &#123; // 重写url &#x27;/api&#x27;:&#x27;&#x27; &#125; &#125; &#125; &#125;&#125;) 配置url 1234const request = axios.create(&#123; baseURL: &#x27;/api&#x27;, //指向代理地址 timeout: 5000&#125;); 4. 重中之重 跨域是后端要配置的 前端只能是伪跨域 发布的时候 baseURL 要切换为真正的后台地址","categories":[],"tags":[{"name":"vue","slug":"vue","permalink":"https://blog.zaiyuan.cc/tags/vue/"},{"name":"cors","slug":"cors","permalink":"https://blog.zaiyuan.cc/tags/cors/"}]},{"title":"dotnet -- 1. publish","slug":"code/dotnet/dotnet -- 1. publish","date":"2023-05-04T13:49:16.264Z","updated":"2022-09-20T19:58:12.000Z","comments":true,"path":"code/dotnet/dotnet -- 1. publish/","link":"","permalink":"https://blog.zaiyuan.cc/code/dotnet/dotnet%20--%201.%20publish/","excerpt":"","text":"dotnet publish1dotnet publish -c Release -r linux-x64 --self-contained false -o ./bin/publish -c-c Release-c Debug","categories":[],"tags":[{"name":"dotnet","slug":"dotnet","permalink":"https://blog.zaiyuan.cc/tags/dotnet/"}]},{"title":"dotnet -- 2. set nuget","slug":"code/dotnet/dotnet -- 2. set nuget","date":"2023-05-04T13:49:16.263Z","updated":"2022-09-20T19:58:12.000Z","comments":true,"path":"code/dotnet/dotnet -- 2. set nuget/","link":"","permalink":"https://blog.zaiyuan.cc/code/dotnet/dotnet%20--%202.%20set%20nuget/","excerpt":"","text":"dotnet nuget add 1dotnet nuget add source &#123;url&#125; -n &#123;name&#125; remove 1dotnet nuget remove source &#123;name&#125; see 1dotnet nuget list source","categories":[],"tags":[{"name":"dotnet","slug":"dotnet","permalink":"https://blog.zaiyuan.cc/tags/dotnet/"}]},{"title":"dotnet -- 3. linux install dotnet","slug":"code/dotnet/dotnet -- 3. linux install dotnet","date":"2023-05-04T13:49:16.261Z","updated":"2023-02-07T23:28:42.000Z","comments":true,"path":"code/dotnet/dotnet -- 3. linux install dotnet/","link":"","permalink":"https://blog.zaiyuan.cc/code/dotnet/dotnet%20--%203.%20linux%20install%20dotnet/","excerpt":"","text":"脚本安装 下载地址: 点击下载 1bash dotnet-install.sh 官网https://learn.microsoft.com/zh-cn/dotnet/core/install/linux","categories":[],"tags":[{"name":"dotnet","slug":"dotnet","permalink":"https://blog.zaiyuan.cc/tags/dotnet/"},{"name":"linux","slug":"linux","permalink":"https://blog.zaiyuan.cc/tags/linux/"}]},{"title":"dotnet -- 4. set 跨域 Cors","slug":"code/dotnet/dotnet -- 4. set 跨域 Cors","date":"2023-05-04T13:49:16.260Z","updated":"2022-09-20T19:58:12.000Z","comments":true,"path":"code/dotnet/dotnet -- 4. set 跨域 Cors/","link":"","permalink":"https://blog.zaiyuan.cc/code/dotnet/dotnet%20--%204.%20set%20%E8%B7%A8%E5%9F%9F%20Cors/","excerpt":"","text":".netcore cors 配置跨域是后端职责所在 核心代码如下: 12345678910111213141516// 从 appsetting 获取跨域列表var hostList = configuration.GetSection(&quot;Cors&quot;).GetChildren().Select(w =&gt; w.Value).ToArray();services.AddCors(setupAction =&gt;&#123; // 配置跨域规则 setupAction.AddPolicy(&quot;cors&quot;, setupAction =&gt; &#123; //setupAction.AllowAnyOrigin(); setupAction.AllowAnyHeader(); setupAction.AllowAnyMethod(); setupAction.AllowCredentials().WithOrigins(hostList); &#125;);&#125;);// 使用跨域中间件app.UseCors(&quot;cors&quot;); 辅助代码 appsetting.json 123456789101112&#123; &quot;Logging&quot;: &#123; &quot;LogLevel&quot;: &#123; &quot;Default&quot;: &quot;Information&quot;, &quot;Microsoft.AspNetCore&quot;: &quot;Warning&quot; &#125; &#125;, &quot;Cors&quot;: [ &quot;http://localhost:5000&quot;, &quot;http://192.168.52.21:5000&quot; ]&#125; configuration, services, app 12345678910111213public class Program&#123; public static void Main(string[] args) &#123; var builder = WebApplication.CreateBuilder(args); var services = builder.Services; var configuration = builder.Configuration; var app = builder.Build(); app.Run(); &#125;&#125;","categories":[],"tags":[{"name":"dotnet","slug":"dotnet","permalink":"https://blog.zaiyuan.cc/tags/dotnet/"},{"name":".netcore","slug":"netcore","permalink":"https://blog.zaiyuan.cc/tags/netcore/"}]},{"title":"dotnet -- 5. 中间件 Middleware","slug":"code/dotnet/dotnet -- 5. 中间件 Middleware","date":"2023-05-04T13:49:16.257Z","updated":"2022-09-20T19:58:12.000Z","comments":true,"path":"code/dotnet/dotnet -- 5. 中间件 Middleware/","link":"","permalink":"https://blog.zaiyuan.cc/code/dotnet/dotnet%20--%205.%20%E4%B8%AD%E9%97%B4%E4%BB%B6%20Middleware/","excerpt":"","text":"概念地址: https://learn.microsoft.com/zh-cn/aspnet/core/fundamentals/middleware/?view=aspnetcore-7.0 常用中间件 异常&#x2F;错误处理 当应用在开发环境中运行时： 开发人员异常页中间件 (UseDeveloperExceptionPage) 报告应用运行时错误。 数据库错误页中间件 (UseDatabaseErrorPage) 报告数据库运行时错误。 当应用在生产环境中运行时： 异常处理程序中间件 (UseExceptionHandler) 捕获以下中间件中引发的异常。 HTTP 严格传输安全协议 (HSTS) 中间件 (UseHsts) 添加 Strict-Transport-Security 标头。 HTTPS 重定向中间件 (UseHttpsRedirection) 将 HTTP 请求重定向到 HTTPS。 静态文件中间件 (UseStaticFiles) 返回静态文件，并简化进一步请求处理。 Cookie 策略中间件 (UseCookiePolicy) 使应用符合欧盟一般数据保护条例 (GDPR) 规定。 用于路由请求的路由中间件 (UseRouting)。 身份验证中间件 (UseAuthentication) 尝试对用户进行身份验证，然后才会允许用户访问安全资源。 用于授权用户访问安全资源的授权中间件 (UseAuthorization)。 会话中间件 (UseSession) 建立和维护会话状态。 如果应用使用会话状态，请在 Cookie 策略中间件之后和 MVC 中间件之前调用会话中间件。 用于将 Razor Pages 终结点添加到请求管道的终结点路由中间件（带有 MapRazorPages 的 UseEndpoints）。123456789101112131415161718if (env.IsDevelopment())&#123; app.UseDeveloperExceptionPage(); app.UseDatabaseErrorPage();&#125;else&#123; app.UseExceptionHandler(&quot;/Error&quot;); app.UseHsts();&#125;app.UseHttpsRedirection();app.UseStaticFiles();app.UseCookiePolicy();app.UseRouting();app.UseAuthentication();app.UseAuthorization();app.UseSession();app.MapRazorPages();","categories":[],"tags":[{"name":"dotnet","slug":"dotnet","permalink":"https://blog.zaiyuan.cc/tags/dotnet/"},{"name":".netcore","slug":"netcore","permalink":"https://blog.zaiyuan.cc/tags/netcore/"}]}],"categories":[],"tags":[{"name":"tools","slug":"tools","permalink":"https://blog.zaiyuan.cc/tags/tools/"},{"name":"joplin","slug":"joplin","permalink":"https://blog.zaiyuan.cc/tags/joplin/"},{"name":"windows","slug":"windows","permalink":"https://blog.zaiyuan.cc/tags/windows/"},{"name":"vscode","slug":"vscode","permalink":"https://blog.zaiyuan.cc/tags/vscode/"},{"name":"dota","slug":"dota","permalink":"https://blog.zaiyuan.cc/tags/dota/"},{"name":"sql","slug":"sql","permalink":"https://blog.zaiyuan.cc/tags/sql/"},{"name":"mysql","slug":"mysql","permalink":"https://blog.zaiyuan.cc/tags/mysql/"},{"name":"docker","slug":"docker","permalink":"https://blog.zaiyuan.cc/tags/docker/"},{"name":"dockerfile","slug":"dockerfile","permalink":"https://blog.zaiyuan.cc/tags/dockerfile/"},{"name":"ddns","slug":"ddns","permalink":"https://blog.zaiyuan.cc/tags/ddns/"},{"name":"nginx","slug":"nginx","permalink":"https://blog.zaiyuan.cc/tags/nginx/"},{"name":"filebrowser","slug":"filebrowser","permalink":"https://blog.zaiyuan.cc/tags/filebrowser/"},{"name":"git","slug":"git","permalink":"https://blog.zaiyuan.cc/tags/git/"},{"name":"linux","slug":"linux","permalink":"https://blog.zaiyuan.cc/tags/linux/"},{"name":"hexo","slug":"hexo","permalink":"https://blog.zaiyuan.cc/tags/hexo/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://blog.zaiyuan.cc/tags/ubuntu/"},{"name":"code","slug":"code","permalink":"https://blog.zaiyuan.cc/tags/code/"},{"name":"ios","slug":"ios","permalink":"https://blog.zaiyuan.cc/tags/ios/"},{"name":"cursor","slug":"cursor","permalink":"https://blog.zaiyuan.cc/tags/cursor/"},{"name":"vue","slug":"vue","permalink":"https://blog.zaiyuan.cc/tags/vue/"},{"name":"vue_cli","slug":"vue-cli","permalink":"https://blog.zaiyuan.cc/tags/vue-cli/"},{"name":"element_ui","slug":"element-ui","permalink":"https://blog.zaiyuan.cc/tags/element-ui/"},{"name":"sass","slug":"sass","permalink":"https://blog.zaiyuan.cc/tags/sass/"},{"name":"cors","slug":"cors","permalink":"https://blog.zaiyuan.cc/tags/cors/"},{"name":"dotnet","slug":"dotnet","permalink":"https://blog.zaiyuan.cc/tags/dotnet/"},{"name":".netcore","slug":"netcore","permalink":"https://blog.zaiyuan.cc/tags/netcore/"}]}